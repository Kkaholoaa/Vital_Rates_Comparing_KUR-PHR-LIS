---
title: "IPM_analyses"
author: "Caroline Rodriguez"
date: "6/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(cache = FALSE)
```

```{r}
## Loading libraries
library(ggplot2)
library(plyr)
library(dplyr)
library(tidyr)
library(reshape2)
library(stringr)
```


```{r BasicIPMsFunctions,}
options(stringsAsFactors=FALSE)

# Global mesh variables 

#Run the first 2 chunks of analysis.Rmd ("Loading dataframes" and "Modify input")
#then calculate the min and max observed sizes
min.size <- 0.9*min(c(ColonyLevel$ln_SS, ColonyLevel$ln_ESc), na.rm = T)
#max.size <- 1.1*max(c(ColonyLevel$ln_SS, ColonyLevel$ln_ESc), na.rm = T)

n = 50 #mesh size / number of cells in the discretized kernel
#min.size <- -2.7  # 2*sqrt((10^-2.7)/pi)  # approx 5 cm  diameter coral
max.size <- 2     # 2*sqrt((10^2)/pi)     # approx 11 m diameter coral (ridiculous, but avoids boundary issues)
rec.size <- -2.5  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral
bin_size <- min.size + c(0:n) * (max.size - min.size)/n #boundary points (the edges of the cells defining the kernel 
y <- 0.5 * (bin_size[1:n]+bin_size[2:(n+1)]) #mesh points (midpoints of cells)
I <- y >= rec.size
delta_size <- y[2] - y[1] #width of cells (h)
  
inv.logit <- function(x) {
  exp(x)/(1+exp(x))
}

################################################################################
###### The growth model ########################################################
################################################################################

growth_function <- function(y, x, g.int, g.slp, g.var) {
  mu <- (g.int + g.slp * x)
  sig <- sqrt(g.var)
  dnorm(y, mean=mu, sd=sig)
}

################################################################################
###### The survival model ######################################################
################################################################################

 survival_function <- function(x, s.int, s.slp) {
   #, s.int, s.slp)
   Line <- s.slp * x + s.int
   u <- inv.logit(Line) # From binomial glm, link = logit function
   # removed bakground mortality due to temp. 
   # Could add something in to add more stochasiticity?
   return(u)
 }


################################################################################
###### The reproduction model ##################################################
################################################################################

reproduction_function <- function(y, x, rec, rec.size=-2.5,ind = TRUE) {
  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral
  if (ind == TRUE){
    out <- rep(0,length(x)) #changed
    out[1:2] <- rec/2} #changed
  
    #out[x < rec.size | y >= rec.size] <- 0}

  if (ind == FALSE){
    out <-  (10^x) * rec
    out[x < rec.size | y >= rec.size] <- 0 #if x is below recruitment size then it doesn't count 
   }
  return(out)
}


################################################################################
########## ... Running the IPM ... #############################################
################################################################################
bigmatrix <- function(ModelParameters) {
  rec <- ModelParameters$rec
  g.int <- ModelParameters$g.int
  g.slp <- ModelParameters$g.slp
  g.var <- ModelParameters$g.var
  s.int <- ModelParameters$s.int
  s.slp <- ModelParameters$s.slp
  
  Reproduction_kernel <- delta_size * outer(y, y, 
                                          reproduction_function, rec = rec)

  Growth_kernel <- delta_size * outer(y, y, growth_function, g.int=g.int, 
                                    g.slp=g.slp, g.var=g.var)
  ## Growth Kernel
  # only works inside the function or if you have done this by had
  #image(y,y,t(Growth_kernel))
  
  Survival_kernel <- survival_function(y, s.int=s.int, s.slp=s.slp)
  
  P <- Growth_kernel
  i <- 1:n

  P[,i] <- Growth_kernel[,i]*Survival_kernel[i]
  
  K <- P + Reproduction_kernel
  
  lam <- Re(eigen(K)$values[1])
  w <- Re(eigen(K)$vectors[,1])
  stabledist <- w/sum(w) # right eigenvector/stable distribution
  v.eigen <- Re(eigen(t(K))$vectors[,1]) #left eigenvector
  reprodvalue <- v.eigen/v.eigen[1] #reproductive value
  
  # lam <- Re(eigen(K)$values[1])
  # w <- Re(eigen(K)$vectors[,1])
  # stabledist <- w/sum(w) # right eigenvector/stable distribution
  # v.eigen <- Re(eigen(t(K))$vectors[,1]) #left eigenvector
  # reprodvalue <- v.eigen/v.eigen[1] #reproductive value

  #compute sensitivity and elasticity matrices using the eigenvectors and eigenvalue
  v.dot.w <- sum(stabledist * reprodvalue) * delta_size
  sens <- outer(reprodvalue,stabledist) / v.dot.w
  elas <- matrix(as.vector(sens) * as.vector(K) / lam, nrow = n)
  
  return(list(K=K, lam=lam, w=stabledist, v=reprodvalue,
              v.dot.w=v.dot.w, sens=sens, elas=elas))
}

```

```{r LoadData_Subsetting,}
# Loading in the data from analysis.Rmd
load("data/Growth_intmod_params.rdata")
load("data/Survival_intmod_params.rdata")
# load("data/Recruitment_sizeIndependent.rdata")
# load("data/Recruitment_sizeDependent.rdata")
load("data/SiteInterval_Gmodfits.rdata")
load("data/SiteInterval_Smodfits.rdata")

# Separating the growth data frame by genera #
POCS_G_1 <- dt[dt$Genus_Code == "POCS",][1,]
POCS_G_1 <- cbind(POCS_G_1, data.frame(g.var=0.230512176))
a        <- GrowthDataFrame[GrowthDataFrame$Genus_Code == "POCS",]
POCS_G_2 <- a[which(a$g.int >0),1:6]
POCS_G   <- rbind(POCS_G_1, POCS_G_2) 

POSP_G_1   <- dt[dt$Genus_Code == "POSP",][1,]
POSP_G_1 <- cbind(POSP_G_1, data.frame(g.var=0.372585621))
b        <- GrowthDataFrame[GrowthDataFrame$Genus_Code == "POSP",]
POSP_G_2 <- b[which(b$g.int >0),1:6]
POSP_G   <- rbind(POSP_G_1, POSP_G_2) 

MOSP_G_1   <- dt[dt$Genus_Code == "MOSP",][1,]
MOSP_G_1 <- cbind(MOSP_G_1, data.frame(g.var=1.102913776))
c        <- GrowthDataFrame[GrowthDataFrame$Genus_Code == "MOSP",] 
MOSP_G_2 <- c[which(c$g.int >0),1:6]
MOSP_G   <- rbind(MOSP_G_1, MOSP_G_2)

##############
#SURVIVAL
# subsetting the survival data frame by genera 
POCS_S_1 <- dS[dS$Genus_Code == "POCS",][1,]
a        <- SurvivalDataFrame[SurvivalDataFrame$Genus_Code == "POCS",]
POCS_S_2 <- a[which(a$s.int >0),1:5]
POCS_S   <- rbind(POCS_S_1,POCS_S_2)

POSP_S_1 <- dS[dS$Genus_Code == "POSP",][1,]
b        <- SurvivalDataFrame[SurvivalDataFrame$Genus_Code == "POSP",]
POSP_S_2 <- b[which(b$s.int >0),1:5]
POSP_S   <- rbind(POSP_S_1,POSP_S_2)

MOSP_S_1 <- dS[dS$Genus_Code == "MOSP",][1,]
c        <- SurvivalDataFrame[SurvivalDataFrame$Genus_Code == "MOSP",] 
MOSP_S_2 <- c[which(c$s.int >0),1:5]
MOSP_S   <- rbind(MOSP_S_1,MOSP_S_2)


# ##############
# #RECRUITMENT
# POCS_R <- subset(dr, Genus_Code == "POCS")
# POSP_R <- subset(dr, Genus_Code == "POSP")
# MOSP_R <- subset(dr, Genus_Code == "MOSP")
# 
# POCS_Rdep <- subset(dr_size, Genus_Code == "POCS")
# POSP_Rdep <- subset(dr_size, Genus_Code == "POSP")
# MOSP_Rdep <- subset(dr_size, Genus_Code == "MOSP")
# 
# POCS_R <- subset(POCS_R,Years == "All_Years" )
# totrecruits_POCS <- sum(POCS_R$Tots_recs_peryear, na.rm = T)
# mean(POCS_R$Tots_recs_peryear, na.rm = T)
# 
# POSP_R <- subset(POSP_R,Years == "All_Years" )
# totrecruits_POSP <- sum(POSP_R$Tots_recs_peryear, na.rm = T)
# mean(POSP_R$Tots_recs_peryear, na.rm = T)
# 
# MOSP_R <- subset(MOSP_R,Years == "All_Years" )
# totrecruits_MOSP <- sum(MOSP_R$Tots_recs_peryear, na.rm = T)
# mean(MOSP_R$Tots_recs_peryear, na.rm = T)


```


#Log likelihood Function
Measure of how well a particular model fits the data
Explains how well a parameter explains the observed data
Hope it will give range of recruitment values that give us a lambda of 1
The value of the parameter (recruitment #) that maximizes the probability of observing data (lambda)
*Will do this later

#Full IPM w/ recruitment model 1 (constant recruitment for all)
```{r}
recvalpc <-  10.23 #21.23
recvalpp <-  10.185 #20.8
recvalmp <-  10.18 #20.94

load("data/SiteInterval_allmodfits_noNAs.rdata")
POCS <- no_NAs[no_NAs$Genus_Code == "POCS",]
POCS_lam <- c()
for (i in 1:nrow(POCS)){ 
  MP_POCS <- list(rec = recvalpc, 
                  g.int = POCS$g.int[i], 
                  g.slp = POCS$g.slp[i], 
                  g.var = POCS$g.var[i], 
                  s.int = POCS$s.int[i], 
                  s.slp = POCS$s.slp[i])
  
  pocs        <- bigmatrix(MP_POCS)
  POCS_lam[i] <- pocs$lam
  K <- pocs$K
  Sens<- pocs$sens
  Elas <- pocs$elas
  write.csv(K, sprintf("data/Kernels/Kernel_POCS_%s_%s.csv", 
                       POCS$Sites[i], POCS$Years[i]))
  write.csv(Sens, sprintf("data/Sens/Sens_POCS_%s_%s.csv", 
                          POCS$Sites[i], POCS$Years[i]))
  write.csv(Elas, sprintf("data/Elas/Elas_POCS_%s_%s.csv", 
                          POCS$Sites[i], POCS$Years[i]))
}
L_POCS <- data.frame(Sites = POCS$Sites, Years = POCS$Years, 
                     Genus_Code = POCS$Genus_Code, Lambdas = POCS_lam)


POSP <- no_NAs[no_NAs$Genus_Code == "POSP",]
POSP_lam <- c()
for (i in 1:nrow(POSP)){
  MP_POSP <- list(rec = recvalpp, 
                  g.int = POSP$g.int[i], 
                  g.slp = POSP$g.slp[i], 
                  g.var = POSP$g.var[i], 
                  s.int = POSP$s.int[i], 
                  s.slp = POSP$s.slp[i])
  posp        <- bigmatrix(MP_POSP)
  POSP_lam[i] <- posp$lam
  K    <- posp$K
  Sens <- posp$sens
  Elas <- posp$elas
  write.csv(K, sprintf("data/Kernels/Kernel_POSP_%s_%s.csv", 
                       POSP$Sites[i], POSP$Years[i]))
  write.csv(Sens, sprintf("data/Sens/Sens_POSP_%s_%s.csv", 
                          POSP$Sites[i], POSP$Years[i]))
  write.csv(Elas, sprintf("data/Elas/Elas_POSP_%s_%s.csv", 
                          POSP$Sites[i], POSP$Years[i]))      
}
L_POSP <- data.frame(Sites = POSP$Sites, Years = POSP$Years, 
                     Genus_Code = POSP$Genus_Code, Lambdas = POSP_lam)

MOSP <- no_NAs[no_NAs$Genus_Code == "MOSP",]
MOSP_lam <- c()
for (i in 1:nrow(MOSP)){
  MP_MOSP <- list(rec = recvalmp, 
                  g.int = MOSP$g.int[i], 
                  g.slp = MOSP$g.slp[i], 
                  g.var = MOSP$g.var[i], 
                  s.int = MOSP$s.int[i], 
                  s.slp = MOSP$s.slp[i])
  
  mosp        <- bigmatrix(MP_MOSP)
  MOSP_lam[i] <- mosp$lam
  K    <- mosp$K
  Sens <- mosp$sens
  Elas <- mosp$elas
  write.csv(K, sprintf("data/Kernels/Kernel_ MOSP_%s_%s.csv", 
                        MOSP$Sites[i],  MOSP$Years[i]))
  write.csv(Sens, sprintf("data/Sens/Sens_ MOSP_%s_%s.csv", 
                           MOSP$Sites[i],  MOSP$Years[i]))
  write.csv(Elas, sprintf("data/Elas/Elas_ MOSP_%s_%s.csv", 
                           MOSP$Sites[i],  MOSP$Years[i]))
}
L_MOSP <- data.frame(Sites = MOSP$Sites, Years = MOSP$Years, 
                     Genus_Code = MOSP$Genus_Code, Lambdas = MOSP_lam)

Lambdas <- rbind(L_POCS, L_POSP, L_MOSP)
save(Lambdas, file = "data/all_Lambdas.rdata")


```


#Plot IPM results
```{r}
#plot growth kernel
image(y,y,t(Growth_kernel), main='growth kernel')
abline(0,1,lwd=3)	# plot 1:1, which represents stasis

#plot survival kernel
plot(y,Survival_kernel,type = 'l', main = 'Survival' )
#this looks kinda weird...shouldn't it be more logistic reg shaped?

#Plot full kernel
y_a <- 2*(sqrt(10^y/pi))

#POCS
png(filename = "figs/POCS_fullK.png")
image(y_a, y_a, t(pocs$K)^.1,)
title(GeneraNames[1], line=-1)
abline(0, 1, lty=2)
legend("bottomright", bty = "n", lty = c(0,0,2), col = 1,
       legend= c(sprintf("recruitment value = %.2f", recvalpc), sprintf("lambda = %.2f",  
                         round(pocs$lam,2)), "1:1 line"))
dev.off()

#POSP
png(filename = "figs/POSP_fullK.png")
image(y, y, t(posp$K)^.1,)
title(GeneraNames[2], line=-1)
abline(0, 1, lty=2)
legend("bottomright", bty = "n", lty = c(0,0,2), col = 1,
       legend= c(sprintf("recruitment value = %.2f", recvalpp), sprintf("lambda = %.2f",  
                         round(posp$lam,2)), "1:1 line"))
dev.off()

#MOSP
png(filename = "figs/MOSP_fullK.png")
image(y, y, t(mosp$K)^.1,)
title(GeneraNames[3], line=-1)
abline(0, 1, lty=2)
legend("bottomright", bty = "n", lty = c(0,0,2), col = 1,
       legend= c(sprintf("recruitment value = %.2f", recvalmp), sprintf("lambda = %.2f",  
                         round(mosp$lam,2)), "1:1 line"))
dev.off()


#Another way to plot full kernel
image(y, y, t(K)^.1, xlab="Size (t)",ylab="Size (t+1)",col=topo.colors(100), main="Kernel")
contour(y,y,t(K)^.1, add = TRUE, drawlabels = TRUE )

#Plot stable size distribution
plot(y, stabledist,xlab="Size",type="l",main="Stable size distribution")

#Plot left eigenvector (reproductive value)
plot(y,reprodvalue,xlab="Size",type="l",main="Reproductive values")

#Plot Elasticity
image(y,y[I],t(elas[I,])^0.2, xlab="Size (t)",ylab="Size (t+1)",main="Elasticity") #[I] cuts out recruitment
abline(0,1,lwd=3)	# plot 1:1

#Plot Sensitivity
image(y,y,t(sens)^0.2, xlab="Size (t)",ylab="Size (t+1)", main="Sensitivity")
abline(0,1,lwd=3)	# plot 1:1

```








