---
title: "IPM_analyses"
author: "Caroline Rodriguez"
date: "6/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(cache = FALSE)
```

```{r}
## Loading libraries

```


```{r LoadData_Subsetting,}
# Loading in the data from analysis.Rmd
GrowthModel   <- load("data/Growth_intmod_params.rdata")
SurvivalModel <- load("data/Survival_intmod_params.rdata")
Recruit_indep <- load("data/Recruitment_sizeIndependent.rdata")
Recruit_dep  <- load("data/Recruitment_sizeDependent.rdata")


# Separating the growth data frame by genera #
POCS_G <- subset(dt, Genus_Code == "POCS") 
POSP_G <- subset(dt, Genus_Code == "POSP")
MOSP_G <- subset(dt, Genus_Code == "MOSP")

##############
#SURVIVAL
# subsetting the survival data frame by genera 
POCS_S <- subset(dS, Genus_Code == "POCS")
POSP_S <- subset(dS, Genus_Code == "POSP")
MOSP_S <- subset(dS, Genus_Code == "MOSP")

##############
#RECRUITMENT
POCS_R <- subset(dr, Genus_Code == "POCS")
POSP_R <- subset(dr, Genus_Code == "POSP")
MOSP_R <- subset(dr, Genus_Code == "MOSP")

POCS_Rdep <- subset(dr_size, Genus_Code == "POCS")
POSP_Rdep <- subset(dr_size, Genus_Code == "POSP")
MOSP_Rdep <- subset(dr_size, Genus_Code == "MOSP")

POCS_R <- subset(POCS_R,Years == "All_Years" )
totrecruits_POCS <- sum(POCS_R$Tots_recs_peryear, na.rm = T)
mean(POCS_R$Tots_recs_peryear, na.rm = T)

POSP_R <- subset(POSP_R,Years == "All_Years" )
totrecruits_POSP <- sum(POSP_R$Tots_recs_peryear, na.rm = T)
mean(POSP_R$Tots_recs_peryear, na.rm = T)

MOSP_R <- subset(MOSP_R,Years == "All_Years" )
totrecruits_MOSP <- sum(MOSP_R$Tots_recs_peryear, na.rm = T)
mean(MOSP_R$Tots_recs_peryear, na.rm = T)

```

```{r Basic IPMs}
options(stringsAsFactors=FALSE)

# Global mesh variables 

#Run the first 2 chunks of analysis.Rmd ("Loading dataframes" and "Modify input")
#then calculate the min and max observed sizes
min.size <- 0.9*min(c(ColonyLevel$ln_SS, ColonyLevel$ln_ESc), na.rm = T)
max.size <- 1.1*max(c(ColonyLevel$ln_SS, ColonyLevel$ln_ESc), na.rm = T)

n = 50 #mesh size / number of cells in the discretized kernel
#min.size <- -2.7  # 2*sqrt((10^-2.7)/pi)  # approx 5 cm  diameter coral
#max.size <- 2     # 2*sqrt((10^2)/pi)     # approx 11 m diameter coral (ridiculous, but avoids boundary issues)
rec.size <- -2.5  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral
bin_size <- min.size + c(0:n) * (max.size - min.size)/n #boundary points (the edges of the cells defining the kernel 
y <- 0.5 * (bin_size[1:n]+bin_size[2:(n+1)]) #mesh points (midpoints of cells)
I <- y >= rec.size
delta_size <- y[2] - y[1] #width of cells (h)
  
inv.logit <- function(x) {
  exp(x)/(1+exp(x))
}

################################################################################
###### The growth model ########################################################
################################################################################

growth_function <- function(y, x, g.int, g.slp, g.var) {
  mu <- (g.int + g.slp * x)
  sig <- sqrt(g.var)
  dnorm(y, mean=mu, sd=sig)
}

################################################################################
###### The survival model ######################################################
################################################################################

 survival_function <- function(x) {
   #, s.int, s.slp)
   Line <- s.slp * x + s.int
   u <- inv.logit(Line) # From binomial glm, link = logit function
   # removed bakground mortality due to temp. 
   # Could add something in to add more stochasiticity?
   return(u)
 }


################################################################################
###### The reproduction model ##################################################
################################################################################

reproduction_function <- function(y, x, rec, rec.size=-2.5,ind = TRUE) {
  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral
  if (ind == TRUE){
    out <- 10^x
    out[1:3] <- out[1:3] * rec}
    #out[x < rec.size | y >= rec.size] <- 0}

  if (ind == FALSE){
    out <-  (10^x) * rec
    out[x < rec.size | y >= rec.size] <- 0 #if x is below recruitment size then it doesn't count 
   }
  return(out)
}


################################################################################
########## ... Running the IPM ... #############################################
################################################################################
bigmatrix <- function(ModelParameters) {
  rec <- ModelParameters$rec
  g.int <- ModelParameters$g.int
  g.slp <- ModelParameters$g.slp
  g.var <- ModelParameters$g.var
  s.int <- ModelParameters$s.int
  s.slp <- ModelParameters$s.slp
  
  Reproduction_kernel <- delta_size * outer(y, y, 
                                          reproduction_function, rec = rec)

  Growth_kernel <- delta_size * outer(y, y, growth_function, g.int=g.int, 
                                    g.slp=g.slp, g.var=g.var)
  ## Growth Kernel
  # only works inside the function or if you have done this by had
  #image(y,y,t(Growth_kernel))
  
  Survival_kernel <- survival_function(y)
  
  P <- Growth_kernel
  i <- 1:n

  P[,i] <- Growth_kernel[,i]*Survival_kernel[i]
  
  K <- P + Reproduction_kernel
  
  lam <- Re(eigen(K)$values[1])
  w <- Re(eigen(K)$vectors[,1])
  stabledist <- w/sum(w) # right eigenvector/stable distribution
  v.eigen <- Re(eigen(t(K))$vectors[,1]) #left eigenvector
  reprodvalue <- v.eigen/v.eigen[1] #reproductive value
  
  return(list(K=K, lam=lam, w=stabledist, v=reprodvalue))
}

```

```{r}
reproduction_function <- function(y, x, rec, rec.size=-2.5,ind = TRUE) {
  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral
  if (ind == TRUE){
    out <- rep(0,length(x)) #changed
    out[1:2] <- rec/2} #changed
  
    #out[x < rec.size | y >= rec.size] <- 0}

  if (ind == FALSE){
    out <-  (10^x) * rec
    out[x < rec.size | y >= rec.size] <- 0 #if x is below recruitment size then it doesn't count 
   }
  return(out)
}

ModelParameters <- MP_MOSP
rec <- 21.5
g.int <- ModelParameters$g.int
g.slp <- ModelParameters$g.slp
g.var <- ModelParameters$g.var
s.int <- ModelParameters$s.int
s.slp <- ModelParameters$s.slp

Reproduction_kernel <- delta_size * outer(y, y, 
                                        reproduction_function, rec = rec)

Growth_kernel <- delta_size * outer(y, y, growth_function, g.int=g.int, 
                                  g.slp=g.slp, g.var=g.var)

Survival_kernel <- survival_function(y)

P <- Growth_kernel
i <- 1:n
P[,i] <- Growth_kernel[,i]*Survival_kernel[i]

K <- P + Reproduction_kernel

lam <- Re(eigen(K)$values[1])
w <- Re(eigen(K)$vectors[,1])
stabledist <- w/sum(w) # right eigenvector/stable distribution
v.eigen <- Re(eigen(t(K))$vectors[,1]) #left eigenvector
reprodvalue <- v.eigen/v.eigen[1] #reproductive value

#compute sensitivity and elasticity matrices using the eigenvectors and eigenvalue
v.dot.w <- sum(stabledist * reprodvalue) * delta_size
sens <- outer(reprodvalue,stabledist) / v.dot.w
elas <- matrix(as.vector(sens) * as.vector(K) / lam, nrow = n)

```

#Log likelihood Function
Measure of how well a particular model fits the data
Explains how well a parameter explains the observed data
Hope it will give range of recruitment values that give us a lambda of 1
The value of the parameter (recruitment #) that maximizes the probability of observing data (lambda)
*Will do this later

#Full IPM w/ recruitment model 1 (constant recruitment for all)
```{r}
recvalpc <- 5.161 #21.23 
recvalpp <- 5.121 #20.8
recvalmp <- 5.11 #20.94

MP_POCS <- list(rec = recvalpc, 
                g.int = POCS_G$g.int[1], 
                g.slp = POCS_G$g.slp[1], 
                g.var = 0.230512176, #0.035
                s.int = POCS_S$s.int[1], 
                s.slp = POCS_S$s.slp[1])

MP_POSP <- list(rec = recvalpp, 
                g.int = POSP_G$g.int[1], 
                g.slp = POSP_G$g.slp[1], 
                g.var = 0.372585621, #0.035
                s.int = POSP_S$s.int[1], 
                s.slp = POSP_S$s.slp[1])

MP_MOSP <- list(rec = recvalmp, 
                g.int = MOSP_G$g.int[1], 
                g.slp = MOSP_G$g.slp[1], 
                g.var = 1.102913776, #0.035
                s.int = MOSP_S$s.int[1], 
                s.slp = MOSP_S$s.slp[1])

pocs <- bigmatrix(MP_POCS)
posp <- bigmatrix(MP_POSP)
mosp <- bigmatrix(MP_MOSP)

print(pocs$lam)
print(posp$lam)
print(mosp$lam)
#print(pocs$w)
#print(pocs$v )

```


#Plot IPM results
```{r}
#plot growth kernel
image(y,y,t(Growth_kernel), main='growth kernel')
abline(0,1,lwd=3)	# plot 1:1, which represents stasis

#plot survival kernel
plot(y,Survival_kernel,type = 'l', main = 'Survival' )
#this looks kinda weird...shouldn't it be more logistic reg shaped?

#Plot full kernel
y_a <- 2*(sqrt(10^y/pi))

#POCS
png(filename = "figs/POCS_fullK.png")
image(y_a, y_a, t(pocs$K)^.1,)
title(GeneraNames[1], line=-1)
abline(0, 1, lty=2)
legend("bottomright", bty = "n", lty = c(0,0,2), col = 1,
       legend= c(sprintf("recruitment value = %.2f", recvalpc), sprintf("lambda = %.2f",  
                         round(pocs$lam,2)), "1:1 line"))
dev.off()

#POSP
png(filename = "figs/POSP_fullK.png")
image(y, y, t(posp$K)^.1,)
title(GeneraNames[2], line=-1)
abline(0, 1, lty=2)
legend("bottomright", bty = "n", lty = c(0,0,2), col = 1,
       legend= c(sprintf("recruitment value = %.2f", recvalpp), sprintf("lambda = %.2f",  
                         round(posp$lam,2)), "1:1 line"))
dev.off()

#MOSP
png(filename = "figs/MOSP_fullK.png")
image(y, y, t(mosp$K)^.1,)
title(GeneraNames[3], line=-1)
abline(0, 1, lty=2)
legend("bottomright", bty = "n", lty = c(0,0,2), col = 1,
       legend= c(sprintf("recruitment value = %.2f", recvalmp), sprintf("lambda = %.2f",  
                         round(mosp$lam,2)), "1:1 line"))
dev.off()


#Another way to plot full kernel
image(y, y, t(K)^.1, xlab="Size (t)",ylab="Size (t+1)",col=topo.colors(100), main="Kernel")
contour(y,y,t(K)^.1, add = TRUE, drawlabels = TRUE )

#Plot stable size distribution
plot(y, stabledist,xlab="Size",type="l",main="Stable size distribution")

#Plot left eigenvector (reproductive value)
plot(y,reprodvalue,xlab="Size",type="l",main="Reproductive values")

#Plot Elasticity
image(y,y[I],t(elas[I,])^0.2, xlab="Size (t)",ylab="Size (t+1)",main="Elasticity") #[I] cuts out recruitment
abline(0,1,lwd=3)	# plot 1:1

#Plot Sensitivity
image(y,y,t(sens)^0.2, xlab="Size (t)",ylab="Size (t+1)", main="Sensitivity")
abline(0,1,lwd=3)	# plot 1:1

```








