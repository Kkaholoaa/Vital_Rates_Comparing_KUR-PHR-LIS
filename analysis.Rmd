---
title: "analysis"
author: "Devynn M Wulstein"
date: "3/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(cache = FALSE)
```

```{r}
## Loading libraries
library(ggplot2)
library(plyr)
library(dplyr)
library(tidyr)
```

# Loading dataframes and modifications
```{r}
# Loading dataframe(s)
AllDataFrame <- load("data/Patch_And_Colony_Data_20201103.rdata")
```

```{r}
# Defining site IDs, genera names, and transition intervals (years) as lists
SiteNames <- as.character(unique(ColonyLevel$Site))
GeneraNames <- as.character(unique(ColonyLevel$Genus_Code))
IntervalYears <- unique(ColonyLevel$Interval_Years)

# Ensuring that the log size values are numbers (I think they are numeric, but maybe not!)
# And that the -Infs are NAs instead
ColonyLevel$ln_ES <- as.numeric(ColonyLevel$ln_ES)
ColonyLevel$ln_SS[ColonyLevel$ln_ES == -Inf] <-NA

ColonyLevel$ln_SS <- as.numeric(ColonyLevel$ln_SS)
ColonyLevel$ln_SS[ColonyLevel$ln_SS == -Inf] <-NA

ColonyLevel <- cbind(ColonyLevel, data.frame(Survival = 
                                               1 - ColonyLevel$Mortality))

# Making the size term yearly
GY <- (ColonyLevel$ln_ES - ColonyLevel$ln_SS)*(1/ColonyLevel$Interval_Year)
ColonyLevel <- cbind(ColonyLevel, data.frame(ln_ESc = 
                                             ColonyLevel$ln_SS + GY))
```

```{r MakingSurv_dat,}
################################################################################
##### Survival dataset #########################################################
## Had issues with the glm because of the data #################################
# This only counts the surv/mortality that happen not the instances 
# where it had happened before and the colony didn't come back
################################################################################

surv_dat <- data.frame()
for (i in 1:nrow(ColonyLevel)){
  if(ColonyLevel$Survival[i] == 0){
    surv_dat <- rbind(surv_dat, data.frame(ColonyID = ColonyLevel$ColonyID[i], 
                                size = ColonyLevel$ln_SS[i-1], survival = 0, 
                                Genus_Code = ColonyLevel$Genus_Code[i],
                                Interval_Years = ColonyLevel$Interval_Years[i],
                                Site = ColonyLevel$Site[i])) 
  }
  else{
    surv_dat <- rbind(surv_dat, data.frame(ColonyID = ColonyLevel$ColonyID[i], 
                                size = ColonyLevel$ln_SS[i], survival = 1, 
                                Genus_Code = ColonyLevel$Genus_Code[i],
                                Interval_Years = ColonyLevel$Interval_Years[i],
                                Site = ColonyLevel$Site[i]))}
}

# modS <- glm(survival ~ size, family = "binomial" , data = surv_dat)
# plot(jitter(survival, 0.1) ~ size, store_dat)
# ss <- seq(-3, 9, 0.1)
# lines(ss, predict(modS, list(size = ss), type="response"), pch=8)
```

# Model parameterization
The aim of this analysis is to calculate the kernel fits (growth, survival, & reproduction) for each combination of genera-site-year and then each separately. 

## Full models:
(1) All terms together, no separation
(2) Each Genera for all sites & interval years
(3) Each Site for all genera & interval years
(4) Each Interval Year for all sites & genera

## Individual models: (the more realistic models that we are more interested in)
(5) Each Genera by interval year, sites are not separated
(6) Each Genera by site, interval years are not separated
(7) Each Site by interval year, genera not separated
(8) Each genera by site and interval year (we will have parameter values that equal site * interval years * genera)

_*these separations only apply to our growth and survival models, reproduction is not modeled this way_

### Growth 
```{r 1 FULLmod Growth, eval = TRUE}
################################################################################
################### Model with no separation of terms: growth ##################
################################################################################
Growth <- subset(ColonyLevel, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")

mod <- lm(ln_ES ~ ln_SS, data = Growth)
SlpVar <- (summary(mod)$sigma)**2
aicVal <- AIC(mod)

# saving model coefficients and notes into dataframe with corresponding uniqueID
GrowthDataFrame <- data.frame(Model_IDs ="All_Genera_n_Sites_n_Years", 
                              g.int = coef(mod)[1], 
                              g.slp = coef(mod)[2], g.var = SlpVar, 
                              AIC = aicVal, growth_notes = 
                                sprintf("Num of transitions used equals %s", 
                                        length(Growth$ln_SS)))
```
```{r 2 GeneraMod Growth,}
################################################################################
######### Genera models: Growth ################################################
################################################################################
  
# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- GeneraNames 
LoopLength <- length(Focus)
minTrans <- 4 # minimum number of transitions

growth <- matrix(0, nrow = 2, ncol = LoopLength)
note <- aic <- Var <- c()

for (i in 1:LoopLength){
  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])
  
  
  # subsetting for growth & shrinkage
  subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")
  
  ln_SS <- subset2$ln_SS
  ln_ES <- subset2$ln_ES
  
  # Saving growth model
  if (length(ln_SS) >= minTrans){
    mod <- lm(ln_ES ~ ln_SS)
    note[i] <- sprintf("Num of transitions = %s", 
                    length(ln_SS))
    
    growth[,i] <- coef(mod)
    Var[i] <- (summary(mod)$sigma)**2
    aic[i] <- AIC(mod)
    }
  
  if (length(ln_SS) < minTrans){
    #setting values to NaNs
    note[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(ln_SS))
    growth[,i] <- NaN
    Var[i] <- NA
    aic[i] <- NA
    }
  
  # Row binding the model results into the growth model dataframe
  
  df <- data.frame(Model_IDs = sprintf("%s_All_Sites_n_Years",Focus[i]), 
                 g.int = growth[1,i], g.slp = growth[2,i], g.var = Var[i], 
                 AIC = aic[i], growth_notes = note[i])
  
  GrowthDataFrame <- rbind(GrowthDataFrame,df)
  }
```
```{r 3 SiteMod Growth,}
################################################################################
######### Site models ##########################################################
################################################################################

# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- SiteNames 
LoopLength <- length(Focus)
minTrans <- 4 # minimum number of transitions

growth <- matrix(0, nrow = 2, ncol = LoopLength)
Var <- aic <- note <- c()

for (i in 1:LoopLength){
  subset1 <- subset(ColonyLevel, Site == Focus[i])
  
  # subsetting for growth & shrinkage
  subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")
  
  ln_SS <- subset2$ln_SS
  ln_ES <- subset2$ln_ES
  
  if (length(ln_SS) > minTrans){
    mod <- lm(ln_ES ~ ln_SS)
    note[i] <- sprintf("Num of transitions = %s", length(ln_SS))
    
    growth[,i] <- coef(mod)
    Var[i] <- (summary(mod)$sigma)**2
    aic[i] <- AIC(mod)}
  
  if (length(ln_SS) <= minTrans){
    #setting values to NaNs
    note[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(ln_SS))
    growth[,i] <- NaN
    Var[i] <- NA
    aic[i] <- NA}

  # saving the growth model
  df <- data.frame(Model_IDs = sprintf("%s_All_Genera_n_Years",Focus[i]), 
                 g.int = growth[1,i], g.slp = growth[2,i], 
                 g.var = Var[i], AIC = aic[i], growth_notes = note[i])
  
  GrowthDataFrame <- rbind(GrowthDataFrame,df)
}

```
```{r 4 YearMod Growth,}
################################################################################
######### Interval Year models #################################################
################################################################################

# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- IntervalYears 
LoopLength <- length(Focus)
minTrans <- 4 # minimum number of colonies

growth <- matrix(0, nrow = 2, ncol = LoopLength)
Var <- note <- aic <- c()
 
for (i in 1:LoopLength){
  subset1 <- subset(ColonyLevel, Interval_Years == Focus[i])
  
  # subsetting for growth & shrinkage
  subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")
  
  ln_SS <- subset2$ln_SS
  ln_ES <- subset2$ln_ES
  
  if (length(ln_SS) > minTrans){
    mod <- lm(ln_ES ~ ln_SS)
    note[i] <- sprintf("Num of transitions = %s", length(ln_SS))
    
    growth[,i] <- coef(mod)
    Var[i] <- (summary(mod)$sigma)**2
    aic[i] <- AIC(mod)}
  
  if (length(ln_SS) <= minTrans){
    #setting values to NaNs
    note[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(ln_SS))
    growth[,i] <- NaN
    Var[i] <- NA
    aic[i] <- NA}
  
  df <- data.frame(Model_IDs = sprintf("%s_All_Genera_n_Sites",Focus[i]), 
                 g.int = growth[1,i], g.slp = growth[2,i], 
                 g.var = Var[i], AIC = aic[i], growth_notes = note[i])
  
  GrowthDataFrame <- rbind(GrowthDataFrame,df)
}

```
```{r 5 Genera + Site Mod Growth,}
################################################################################
######### Genera + Site for all Interval Years models: growth ##################
################################################################################

# define the parms for model loop
# Now with a second "Focus"
Focus <- GeneraNames
subFocus <- SiteNames
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of colonies
minTrans <- 4 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  growth <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  note <- Var <- aic <- c()
  
  # subset ColonyLevel to specify first focus
  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])
  
  for (v in 1:LoopLengthSF){
    # subsetting for growth & shrinkage
    subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                 TransitionTypeSimple == "SHRINK")
    
    # subsetting growth & shrinkage for second focus
    subset3 <- subset(subset2, Site == subFocus[v])
    
    ln_SS <- subset3$ln_SS
    ln_ES <- subset3$ln_ES
    
    if (length(ln_SS) > minTrans){
      mod <- lm(ln_ES ~ ln_SS)
      note[v] <- sprintf("Num of transitions = %s", length(ln_SS))
      growth[,v] <- coef(mod)
      Var[v] <- (summary(mod)$sigma)**2
      aic[v] <- AIC(mod)}
    
    if (length(ln_SS) <= minTrans){
      #setting values to NaNs
      note[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(ln_SS))
      growth[,v] <- NaN
      Var[v] <- NA
      aic[v] <- NA}
    
  df <- data.frame(Model_IDs = sprintf("%s_%s_All_Years",Focus[i], subFocus[v]), 
                 g.int = growth[1,v], g.slp = growth[2,v], 
                 g.var = Var[v], AIC = aic[v], growth_notes = note[v])
  
  GrowthDataFrame <- rbind(GrowthDataFrame,df)
  
  }} 
  
```
```{r 6 Genera + Years Mod Growth,}
################################################################################
######### Genera + Interval Years for all Site models ##########################
################################################################################

# define the parms for model loop
# Now with a second "Focus"

Focus <- GeneraNames
subFocus <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of transitions
minTrans <- 4 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  growth <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  survival <- growth
  note <- Var <- aic <- c()
  Snote <- Var_S <- aic_S <- c()
  
  # subset data frames to specify first focus
  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])

  for (v in 1:LoopLengthSF){
    
    # subsetting for growth & shrinkage
    subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                 TransitionTypeSimple == "SHRINK")
    
    # subsetting growth & shrinkage for second focus
    subset3 <- subset(subset2, Interval_Years == subFocus[v])
    
    ln_SS <- subset3$ln_SS
    ln_ES <- subset3$ln_ES

    if (length(ln_SS) > minTrans){
      mod <- lm(ln_ES ~ ln_SS)
      note[v] <- sprintf("Num of transitions = %s", length(ln_SS))
      growth[,v] <- coef(mod)
      Var[v] <- (summary(mod)$sigma)**2
      aic[v] <- AIC(mod)}
    
    if (length(ln_SS) <= minTrans){
      #setting values to NaNs
      note[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(ln_SS))
      growth[,v] <- NaN
      Var[v] <- NA
      aic[v] <- NA}
    
    df <- data.frame(Model_IDs = sprintf("%s_%s_All_Sites",Focus[i], subFocus[v]), 
               g.int = growth[1,v], g.slp = growth[2,v], 
               g.var = Var[v], AIC = aic[v], growth_notes = note[v])
  
    GrowthDataFrame <- rbind(GrowthDataFrame,df)
  
}}
```
```{r 7 Site + Years Mod Growth,}
################################################################################
######### Site + Interval Years for all Genera models ##########################
################################################################################

# define the parms for model loop
# Now with a second "Focus"

Focus <-SiteNames
subFocus <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of transitions
minTrans <- 4 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  growth <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  survival <- growth
  note <- Var <- aic <- c()
  Snote <- Var_S <- aic_S <- c()
  
  # subset ColonyLevel to specify first focus
  subset1 <- subset(ColonyLevel, Site == Focus[i])


  for (v in 1:LoopLengthSF){
    
    # subsetting for growth & shrinkage
    subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                 TransitionTypeSimple == "SHRINK")
    
    # subsetting for Interval_Years
    subset3 <- subset(subset2, Interval_Years == subFocus[v])
    
    ln_SS <- subset3$ln_SS
    ln_ES <- subset3$ln_ES
    
    if (length(ln_SS) > minTrans){
      mod <- lm(ln_ES ~ ln_SS)
      note[v] <- sprintf("Num of transitions = %s", length(ln_SS))
      growth[,v] <- coef(mod)
      Var[v] <- (summary(mod)$sigma)**2
      aic[v] <- AIC(mod)}
    
    if (length(ln_SS) <= minTrans){
      #setting values to NaNs
      note[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(ln_SS))
      growth[,v] <- NaN
      Var[v] <- NA
      aic[v] <- NA}
    
    # saving growth model 
    
    df <- data.frame(Model_IDs = sprintf("%s_%s_All_Genera",Focus[i], subFocus[v]), 
             g.int = growth[1,v], g.slp = growth[2,v], 
             g.var = Var[v], AIC = aic[v], growth_notes = note[v])
  
    GrowthDataFrame <- rbind(GrowthDataFrame,df)
  }}
```
```{r 8 Genera + Site + Years Mod Growth,}
################################################################################
######### Genera + Site + Interval Years  models ###############################
########## GROWTH ! ############################################################
################################################################################
# define the parms for model loop
# Now with a second "Focus"

Focus <- GeneraNames
subFocus <- SiteNames
subFocus2 <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)
LoopLengthSF2 <-  length(subFocus2)

minTrans <- 4 

for (i in 1:LoopLength){
  
  # subset Genus_Code for specific genera
  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])

  for (v in 1:LoopLengthSF){
    
    # redefine the matrix for each Focus step
    growth <- matrix(0, nrow = 2, ncol = LoopLengthSF2)
    note <- Var <- aic <- c()
    
    # subsetting for growth & shrinkage
    subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                 TransitionTypeSimple == "SHRINK")
    
    # subsetting growth & shrinkage for specific Site
    subset3 <- subset(subset2, Site == subFocus[v])
    
    for (y in 1:LoopLengthSF2){
      
      #subsetting genera specific & Site specific into interval year specific
      subset4 <- subset(subset3, Interval_Years == subFocus2[y])
      
      ln_SS <- subset4$ln_SS
      ln_ES <- subset4$ln_ES
      
      if (length(ln_SS) > minTrans){
        mod <- lm(ln_ES ~ ln_SS)
        note[y] <- sprintf("Num of transitions = %s", length(ln_SS))
        growth[,y] <- coef(mod)
        Var[y] <- (summary(mod)$sigma)**2
        aic[y] <- AIC(mod)}
      
      if (length(ln_SS) <= minTrans){
        #setting values to NaNs
        note[y] <- sprintf("Not enough data. Num transitions = %s", 
                        length(ln_SS))
        growth[,y] <- NaN
        Var[y] <- NA
        aic[y] <- NA}
      
      df <- data.frame(Model_IDs = sprintf("%s_%s_%s",Focus[i], 
                                           subFocus[v], subFocus2[y]), 
                 g.int = growth[1,y], g.slp = growth[2,y], 
                 g.var = Var[y], AIC = aic[y], growth_notes = note[y])
      
      GrowthDataFrame <- rbind(GrowthDataFrame,df)
}}}

```

### Survival
```{r 1 FULLmod Survival,}
################################################################################
################### Model with no separation of terms: survival ################
################################################################################

modS <- glm(survival ~ size, family = "binomial" , data = surv_dat)
aicValS <- AIC(modS)


# saving model coefficients and notes into dataframe with corresponding uniqueID
SurvivalDataFrame <- data.frame(Model_IDs = "All_Genera_n_Sites_n_Years", 
                                s.int = coef(modS)[1], s.slp = coef(modS)[2], 
                                AIC = aicValS, survival_notes = 
                                sprintf("Num of transitions used equals %s", 
                                        length(surv_dat$size)))

```
```{r 2 GeneraMod Survival,}
################################################################################
######### Genera models: Survival ##############################################
################################################################################
Focus <- GeneraNames 
LoopLength <- length(Focus)
minTrans <- 4 # minimum number of transitions
survival <- matrix(0, nrow = 2, ncol = LoopLength)
Snote <- aic_S  <- c()

for (i in 1:LoopLength){
  subset1_S <- subset(surv_dat, Genus_Code == Focus[i])
# Saving survival model
  
  if (length(subset1_S$size) >= minTrans){
    modS <- glm(survival ~ size, family = "binomial" , data = subset1_S)
    Snote[i] <- sprintf("Num of transitions = %s", 
                    length(subset1_S$size))
    
    survival[,i] <- coef(modS)
    aic_S[i] <- AIC(modS)
    }
  
  if (length(subset1_S$size) < minTrans){
    #setting values to NaNs
    Snote[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(subset1_S$size))
    survival[,i] <- NaN
    aic_S[i] <- NA
  }
  
  # Row binding the model results into the growth model dataframe
  
  dfS <- data.frame(Model_IDs = sprintf("%s_All_Sites_n_Years",Focus[i]), 
                                s.int = survival[1,i], s.slp = survival[2,i], 
                                AIC = aic_S[i], survival_notes = Snote[i])
  
  SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
  
}

# the model does converge here  

 
```
```{r 3 SiteMod Survival,}
################################################################################
######### Site models: Survival ################################################
################################################################################

# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- SiteNames 
LoopLength <- length(Focus)
minTrans <- 4 # minimum number of transitions

survival <- matrix(0, nrow = 2, ncol = LoopLength)
Snote <- aic_S <- c()

for (i in 1:LoopLength){
  subset1_S <- subset(surv_dat, Site == Focus[i])
  
  if (length(subset1_S$size) >= minTrans){
    modS <- glm(survival ~ size, family = "binomial" , data = subset1_S)
    Snote[i] <- sprintf("Num of transitions = %s", 
                    length(subset1_S$size))
    
    survival[,i] <- coef(modS)
    aic_S[i] <- AIC(modS)
    }
  
  if (length(subset1_S$size) < minTrans){
    #setting values to NaNs
    Snote[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(subset1_S$size))
    survival[,i] <- NaN
    Var_S[i] <- NA
    aic_S[i] <- NA
    }
  

 # Row binding the model results into the growth model dataframe
  
  dfS <- data.frame(Model_IDs = sprintf("%s_All_Genera_n_Years",Focus[i]), 
                                s.int = survival[1,i], s.slp = survival[2,i], 
                                AIC = aic_S[i], survival_notes = Snote[i])
  
  SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
  }

## Getting the error: "glm.fit: algorithm did not converge" might need to start this loop with a new dataframe for the survival data? 
```
```{r 4 YearMod Survival,}
################################################################################
########## Interval Year models: survival ######################################
################################################################################

# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- IntervalYears 
LoopLength <- length(Focus)
minTrans <- 4 # minimum number of colonies

survival <- matrix(0, nrow = 2, ncol = LoopLength)
Snote <- aic_S <- c()

for (i in 1:LoopLength){
  subset1_S <- subset(surv_dat, Interval_Years == Focus[i])
  
   # Survival model 
  if (length(subset1_S$size) >= minTrans){
    modS <- glm(survival ~ size, family = "binomial" , data = subset1_S)
    Snote[i] <- sprintf("Num of transitions = %s", 
                    length(subset1_S$size))
    
    survival[,i] <- coef(modS)
    aic_S[i] <- AIC(modS)
    }
  
  if (length(subset1_S$size) < minTrans){
    #setting values to NaNs
    Snote[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(subset1_S$size))
    survival[,i] <- NaN
    aic_S[i] <- NA
    }
  

  # Row binding the model results into the growth model dataframe
  
  dfS <- data.frame(Model_IDs = sprintf("%s_All_Genera_n_Sites",Focus[i]), 
                                s.int = survival[1,i], s.slp = survival[2,i], 
                                AIC = aic_S[i], survival_notes = Snote[i])
  
  SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
  
}

## Getting the error: "glm.fit: algorithm did not converge" might need to start this loop with a new dataframe for the survival data? 
```
```{r 5 Genera + Site Mod Survival,}
################################################################################
######### Genera + Site for all Interval Years models: survival ################
################################################################################

# define the parms for model loop
Focus <- GeneraNames
subFocus <- SiteNames
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of colonies
minTrans <- 4 

for (i in 1:LoopLength){
  survival <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  Snote <- aic_S <- c()

  subset1_S <- surv_dat[surv_dat$Genus_Code == Focus[i],]

  for (v in 1:LoopLengthSF){
    #v = 8
    subset2_S <- subset1_S[subset1_S$Site == subFocus[v],]
    
    if (nrow(subset2_S) == 0){
      #setting values to NaNs
    Snote[v] <- sprintf("No data for %s and %s", Focus[i], subFocus[v])
    survival[,v] <- NaN
    aic_S[v] <- NA
    }
    
    if (length(subset2_S$size) >= minTrans){
    modS <- glm(survival ~ size, family = "binomial" , data = subset2_S)
    Snote[v] <- sprintf("Num of patches = %s", 
                    length(subset2_S$size))
    
    survival[,v] <- coef(modS)
    aic_S[v] <- AIC(modS)
    }
  
  if (length(subset2_S$size) < minTrans){
    #setting values to NaNs
    Snote[v] <- sprintf("Not enough data. Num patches = %s", 
                    length(subset2_S$size))
    survival[,v] <- NaN
    aic_S[v] <- NA
    }
  
  
  dfS <- data.frame(Model_IDs = sprintf("%s_All_Years",Focus[v]), 
                                s.int = survival[1,v], s.slp = survival[2,v], 
                                AIC = aic_S[v], survival_notes = Snote[v])
  
  SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
   
   
  }
}
```
```{r 6 Genera + Years Mod Survival,}
################################################################################
######### Genera + Interval Years for all Site models ##########################
################################################################################

# define the parms for model loop
# Now with a second "Focus"

Focus <- GeneraNames
subFocus <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of transitions
minTrans <- 4 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  survival <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  Snote <- aic_S <- c()
  
  # subset data frames to specify first focus
  subset1_S <- subset(surv_dat, Genus_Code == Focus[i])

  for (v in 1:LoopLengthSF){

    # subsetting growth & shrinkage for second focus
    subset2_S <- subset(subset1_S, Interval_Years == subFocus[v])
    
    # Survival model 
    if (length(subset2_S$size) >= minTrans){
      modS <- glm(survival ~ size, family = "binomial" , data = subset2_S)
      Snote[v] <- sprintf("Num of transitions = %s", 
                      length(subset2_S$size))
      
      survival[,v] <- coef(modS)
      aic_S[v] <- AIC(modS)
      }
    
    if (length(subset2_S$size) < minTrans){
      #setting values to NaNs
      Snote[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(subset2_S$size))
      survival[,v] <- NaN
      aic_S[v] <- NA
      }
    
  
    # Row binding the model results into the growth model dataframe
    
    dfS <- data.frame(Model_IDs = sprintf("%s_All_Sites",Focus[v]), 
                                  s.int = survival[1,v], s.slp = survival[2,v], 
                                  AIC = aic_S[v], survival_notes = Snote[v])
    
    SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
  }

}

```
```{r 7 Site + Years Mod Survival,}
################################################################################
######### Site + Interval Years for all Genera models ##########################
################################################################################

# define the parms for model loop
# Now with a second "Focus"

Focus <-SiteNames
subFocus <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of transitions
minTrans <- 4 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  survival <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  Snote<- aic_S <- c()
  
  # subset ColonyLevel to specify first focus
  subset1 <- subset(surv_dat, Site == Focus[i])

  for (v in 1:LoopLengthSF){
    
    # subsetting for Interval_Years
    subset2_S <- subset(subset1_S, Interval_Years == subFocus[v])

    # Survival model 
    if (length(subset2_S$size) >= minTrans){
      modS <- glm(survival ~ size, family = "binomial" , data = subset2_S)
      Snote[v] <- sprintf("Num of transitions = %s", 
                      length(subset2_S$size))
      
      survival[,v] <- coef(modS)
      aic_S[v] <- AIC(modS)
      }
    
    if (length(subset2_S$size) < minTrans){
      #setting values to NaNs
      Snote[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(subset2_S$size))
      survival[,v] <- NaN
      aic_S[v] <- NA
      }
    
  
    # Row binding the model results into the survival model dataframe
    
    dfS <- data.frame(Model_IDs = sprintf("%s_All_Genera",Focus[v]), 
                                  s.int = survival[1,v], s.slp = survival[2,v], 
                                  AIC = aic_S[v], survival_notes = Snote[v])
    
    SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
     
  
  }

}


```
```{r 8 Genera + Site + Years Mod Survival,}
################################################################################
######### Genera + Site + Interval Years  models ###############################
## SURVIVAL ! ##################################################################
################################################################################
# define the parms for model loop
# Now with a second "Focus"

Focus <- GeneraNames
subFocus <- SiteNames
subFocus2 <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)
LoopLengthSF2 <-  length(subFocus2)

minTrans <- 4 

for (i in 1:LoopLength){
  
  # subset Genus_Code for specific genera
  subset1_S <- subset(surv_dat, Genus_Code == Focus[i])

  for (v in 1:LoopLengthSF){
    
    # redefine the matrix for each Focus step
    survival <- matrix(0, nrow = 2, ncol = LoopLengthSF2)
    Snote <- aic_S <- c()
    
    #subsetting genera specific into Site specific
    subset2_S <- subset(subset1_S, Site == subFocus[v])
    
    for (y in 1:LoopLengthSF2){
      #subsetting genera specific & Site specific into interval year specific
      subset3_S <- subset(subset2_S, Interval_Years == subFocus2[y])

# Survival model 
    if (length(subset3_S$size) >= minTrans){
      modS <- glm(survival ~ size, family = "binomial" , data = subset3_S)
      Snote[y] <- sprintf("Num of transitions = %s", 
                      length(subset3_S$size))
      
      survival[,y] <- coef(modS)
      aic_S[y] <- AIC(modS)
      }
    
    if (length(subset3_S$size) < minTrans){
      #setting values to NaNs
      Snote[y] <- sprintf("Not enough data. Num transitions = %s", 
                      length(subset3_S$size))
      survival[,y] <- NaN
      aic_S[y] <- NA
      }
    
  
    # Row binding the model results into the survival model dataframe
    
    dfS <- data.frame(Model_IDs = sprintf("%s_%s_%s",Focus[i], 
                                           subFocus[v], subFocus2[y]), 
                                  s.int = survival[1,y], s.slp = survival[2,y], 
                                  AIC = aic_S[y], survival_notes = Snote[y])
    
    SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
      
    }}}

```

### Reproduction
Work in progress. 
```{r SurvivalMods, eval=TRUE}

# define the parms for model loop
Focus <- GeneraNames 
LoopLength <- length(Focus)

recruit_genera <- matrix(NaN, nrow = length(IntervalYears), ncol = LoopLength)

# These all depend on the interval years so it doesn't totally makes sense to get a model for that since we want a yearly recruitment rate.

# Calculate the rec vals for each genera at all sites
# Separate each genera 
# - for each unique interval year, take the sum of the area before recuritment (StartingSize)
# - get the num of recurites for each unique interval year
# - num rec / area * interval year (recruit/area*year)
# - should have 3 numbers
# Can leave it as vector for interval years or take an average...?

for (i in 1:LoopLength){

  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])
  
  #calculate unique time intervals
  timeint_all <- unique(subset1$Interval_Years)
  
  rec <- c()
  area <- rep(0,length(timeint_all)) #initalize vector
  for (w in 1:length(timeint_all)){
  area[w] <- sum(subset1$StartingSize[which(subset1$Interval_Years ==
                                              timeint_all[w])])
  if (area[w] == 0) area[w]<- NA
  rec[w] <- sum(subset1$Recruit[which(subset1$Interval_Years ==
                                              timeint_all[w])])}
  
  rec <- rec / area * timeint_all # this is the number multiplied by the total area at each time step to give the number of recurits at the following time step.
  
  recruit_genera[(1:length(rec)),i] <- rec
}

# Calculate the rec vals for each site all genera together
# -similar process as above, should have 11 #s
# define the parms for model loop
Focus <- SiteNames 
LoopLength <- length(Focus)

recruit_site <- matrix(NaN, nrow = length(IntervalYears), ncol = LoopLength)
for (i in 1:LoopLength){

  subsetz <- subset(ColonyLevel, Site == Focus[i])
  
  #calculate unique time intervals
  timeint_all <- unique(subsetz$Interval_Years)
  
  rec <- c()
  area <- rep(0,length(timeint_all)) #initalize vector
  for (w in 1:length(timeint_all)){
  area[w] <- sum(subsetz$StartingSize[which(subsetz$Interval_Years ==
                                              timeint_all[w])])
  if (area[w] == 0) area[w]<- NA
  rec[w] <- sum(subsetz$Recruit[which(subsetz$Interval_Years ==
                                              timeint_all[w])])}
  
  rec <- rec / area * timeint_all # this is the number multiplied by the total area at each time step to give the number of recurits at the following time step.
  
  recruit_site[(1:length(rec)),i] <- rec
}
# Calculate the rec vals for each site and each genera there
# - similar to before but with 33 possible values (not all sites had recruits for some genera)
Focus <- GeneraNames
subFocus <- SiteNames
LoopLength <- length(Focus)
LoopLengthSF <- length(subFocus)

df <- data.frame()

for (t in 1:LoopLength){
  recruit <- matrix(NaN, nrow = length(IntervalYears), ncol = LoopLengthSF)
  
  subseta <- subset(ColonyLevel, Genus_Code == Focus[t])
  
  for( i in 1:LoopLengthSF){
    
    subsetz <- subseta[subseta$Site == subFocus[i],]
    #calculate unique time intervals
    timeint_all <- unique(subsetz$Interval_Years)
    
    rec <- c()
    area <- rep(0,length(timeint_all)) #initalize vector
    
    if (nrow(subsetz) == 0) rec <- NaN
    
    else{  
      rec[w] <- sum(subsetz$Recruit[which(subsetz$Interval_Years ==
                                                timeint_all[w])])
      for (w in 1:length(timeint_all)){
      area[w] <- sum(subsetz$StartingSize[which(subsetz$Interval_Years ==
                                                timeint_all[w])])
      }
      rec <- rec / area * timeint_all
    }
     # this is the number multiplied by the total area at each time step to give the number of recurits at the following time step.
    
    recruit[(1:length(rec)),i] <- rec
  }
  df <- rbind(df, data.frame(Genus_Code = GeneraNames[t], rec_info = recruit))
}


```


Testing the model interactions. Maybe this makes more sense to have earlier on the page but this is here for reference as to why we coded the models this way. We were interested in extracting the values for the IPM parameters.

```{r Interactions,}
################################################################################
# Model interactions by genus: Growth ##########################################
#### SITE ######################################################################
################################################################################

mod_site_POCS <- lm(ln_ES ~ ln_SS + Site, 
           data = Growth[Growth$Genus_Code == GeneraNames[1],])
summary(mod_site_POCS)
drop1(mod_site_POCS, test="F")

mod_site_POSP <- lm(ln_ES ~ ln_SS + Site, 
           data = Growth[Growth$Genus_Code == GeneraNames[2],])
summary(mod_site_POSP)
drop1(mod_site_POSP, test="F")

mod_site_MOSC <- lm(ln_ES ~ ln_SS + Site, 
           data = Growth[Growth$Genus_Code == GeneraNames[3],])
summary(mod_site_MOSC)
drop1(mod_site_MOSC, test="F")

################################################################################
# Model interactions by genus: Survival ########################################
#### SITE ######################################################################
################################################################################

modS_site_POCS <- glm(survival ~ size + Site, family = "binomial" ,
           data = surv_dat[surv_dat$Genus_Code == GeneraNames[1],])
summary(modS_site_POCS)
drop1(modS_site_POCS, test="F")

modS_site_POSP <- glm(survival ~ size + Site, family = "binomial" , 
           data = surv_dat[surv_dat$Genus_Code == GeneraNames[2],])
summary(modS_site_POSP)
drop1(modS_site_POSP, test="F")

modS_site_MOSC <- glm(survival ~ size + Site, family = "binomial" , 
           data = surv_dat[surv_dat$Genus_Code == GeneraNames[3],])
summary(modS_site_MOSC)
drop1(modS_site_MOSC, test="F")
```


```{r Basic IPMs}

options(stringsAsFactors=FALSE)

# Global mesh variables 

min.size <- -2.7  # 2*sqrt((10^-2.7)/pi)  # approx 5 cm  diameter coral
max.size <- 2     # 2*sqrt((10^2)/pi)     # approx 11 m diameter coral (ridiculous, but avoids boundary issues)
rec.size <- -2.5  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral

inv.logit <- function(x) {
  exp(x)/(1+exp(x))
}

################################################################################
###### The growth model ########################################################
################################################################################

growth_function <- function(y, x, g.int, g.slp, g.var) {
  mu <- (g.int + g.slp * x)
  sig <- sqrt(g.var)
  dnorm(y, mean=mu, sd=sig)
}

################################################################################
###### The survival model ######################################################
################################################################################

survival_function <- function(x, s.int, s.slp) {
  u <- inv.logit(s.int + s.slp * x) # From binomial glm, link = logit function
  # removed bakground mortality due to temp. 
  # Could add something in to add more stochasiticity?
}
################################################################################
###### The reproduction model ##################################################
################################################################################

reproduction_function <- function(y, x, rec, rec.size=-2.5) {
  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral
  out <-  (10^x) * rec
  out[x < rec.size | y >= rec.size] <- 0 #if x is below recruitment size then it doesn't count 
  return(out)
}

################################################################################
########## ... Running the IPM ... #############################################
################################################################################
bigmatrix <- function(ModelParameters) {
  rec <- ModelParameters$rec
  g.int <- ModelParameters$g.int
  g.slp <- ModelParameters$g.slp
  g.var <- ModelParameters$g.var
  s.int <- ModelParameters$s.int
  s.slp <- ModelParameters$s.slp
  
  Reproduction_kernel <- delta_size * 
    outer(y, y, reproduction_function, 
          rec = "[Insert the rec value from models]")
  
  Growth_kernel <- delta_size * outer(y, y, growth_function, g.int=g.int, 
                                      g.slp=g.slp, g.var=g.var)
  Survival_kernel <- outer(y, survival_function, s.int=s.int, s.slp=s.slp)
  
  P <- Growth_kernel
  i <- 1:n_individuals
  P[,i] <- Growth_kernel[,i]*Survival_kernel[i]
  
  K <- P + Reproduction_kernel
  
  lam <- Re(eigen(K)$values[1])
  v <- Re(eigen(K)$vectors[,1])
  v <- v/sum(v) # right eigenvector/stable distribution
  
  return(list(K=K, lam=lam, v=v))
}
```


#Plot full growth model1
```{r Plotting full growth model 1, }
plot(ln_ES ~ ln_SS ,data = ColonyLevel)
abline(a=Glist_genera$g.int[1], b=Glist_genera$g.slp[1], col='red', lwd=2)
abline(a=Glist_genera$g.int[2], b=Glist_genera$g.slp[2], col='blue', lwd=2)
abline(a=Glist_genera$g.int[3], b=Glist_genera$g.slp[3], col='green', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("red","blue","green"),
       legend= GeneraNames , cex = 0.8)

#plot each genus separately
par(mfrow=c(1,3))
#Pocillopora
plot(ln_ES ~ ln_SS ,data = ColonyLevel,
     main="Pocillopora growth fit at all sites")
abline(a=Glist_genera$g.int[1], b=Glist_genera$g.slp[1], col='red', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("red"),
       legend= 'POCS' , cex = 0.8)
#Porites
plot(ln_ES ~ ln_SS ,data = ColonyLevel, 
     main="Porites growth fit at all sites")
abline(a=Glist_genera$g.int[2], b=Glist_genera$g.slp[2], col='blue', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("blue"),
       legend= 'POSP' , cex = 0.8)
#Montipora
plot(ln_ES ~ ln_SS ,data = ColonyLevel, 
     main="Montipora growth fit at all sites")
abline(a=Glist_genera$g.int[3], b=Glist_genera$g.slp[3], col='green', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("green"),
       legend= 'MOSP' , cex = 0.8)

```
#Plotting full growth model 2
```{r Plotting full growth model 2,}

#Plot full growth model2
LoopLeng <- length(SiteNames)
plot(ln_ES ~ ln_SS ,data = ColonyLevel, 
     main="Each site growth fit for all genera + all interval years")
for (i in 1:LoopLeng) {
  abline(a=Glist_site$g.int[i], b=Glist_site$g.slp[i], col=i , lwd=2)
}
legend("topleft", bty = "n", lty = c(1,1), col = 1:11,
       legend= SiteNames , cex = 0.8, pt.cex = .7)


#plot each site's growth model separately
LoopLeng <- length(SiteNames)
par(mfrow=c(4,3))
for (h in 1:LoopLeng) {
  plot(ln_ES ~ ln_SS ,data = ColonyLevel)
    abline(a=Glist_site$g.int[h], b=Glist_site$g.slp[h], col=h , lwd=2)
  legend("topleft", bty = "n", lty = c(1,1), col = h,
         legend= SiteNames[h], cex = 0.6, pt.cex = .5)
}

```

#Plot full growth model 3
Each Interval Year for all sites & genera
```{r Plotting full growth model 2,}
#Plot full growth model3
#mad right now bc of NA values
LoopL <- length(IntervalYears)
plot(ln_ES ~ ln_SS ,data = ColonyLevel, 
     main="Each interval growth fit for all genera + all sites")
for (m in 1:LoopL) {
  abline(a=Glist_years$g.int[m], b=Glist_years$g.slp[m], col=m , lwd=2)
}
legend("topleft", bty = "n", lty = c(1,1), col = 1:11,
       legend= IntervalYears, cex = 0.8, pt.cex = .7)


#which(is.na(Glist_years$g.slp)) #in which index is the glope NA?
#why does interval year 4.26557 have a negative slope?
#ColonyLevel$Site[ColonyLevel$Interval_Years == IntervalYears[10]] #ID the site that is in the 10th position in IntervalYears

#plot each site's growth model separately
par(mfrow=c(4,3))
for (c in 1:LoopL) {
  plot(ln_ES ~ ln_SS ,data = ColonyLevel, 
       main="Each interval growth fit for all genera + all sites")
    abline(a=Glist_years$g.int[c], b=Glist_years$g.slp[c], col=c , lwd=2)
  legend("topleft", bty = "n", lty = c(1,1), col = c,
         legend= IntervalYears[c], cex = 0.6, pt.cex = .5)
}

```

#TO DO
[X] Run growth individual models 4-6
[X] Plot each genus separately (full growth model)
[X] Plot full growth model 2&3
[X] Figure out how to save into dataframe
[ ] Clean up script
[ ] Make powerpoint with some of our script and the plots
#Caroline
[ ] Fix growth plots (changed from list to df)
[ ] Plot survival models
[ ] Operationalize reprodution script
[ ] Plot reproduction models
[ ] Plot each individual growth model
#Devynn
[X] Add in survival to models 1-7
[X] Add AIC calcs into the dataframe
[X] Add variance into the dataframe
[X] Maybe add reproduction into models 1-7?
[X] Start IPM chunk set up
[ ] Put everything into a dataframe
[ ] Run Growth Models with standardized sizes
[ ] Figure out issues with survival




#Main Questions for Friday meeting
1. Is this a good way to do the models? Should we be including interaction terms?
2. Why does IntervalYears not work as an interaction term?
- Because it is being considered as a continuous variable 
3. Does the way that we're modeling reproduction (# of recruits/total area from starting point) make sense? 
    - the values are really small when normalized and especially when the interval year is included! tiny! 
4. Should we make everything into something that is on the same playing field (convert growth to something that is actually yearly)?







