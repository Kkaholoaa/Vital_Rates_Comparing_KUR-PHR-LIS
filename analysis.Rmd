---
title: "analysis"
author: "Devynn M Wulstein"
date: "3/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(cache = FALSE)
```

```{r}
## Loading libraries
library(ggplot2)
library(plyr)
library(dplyr)
library(tidyr)
library(reshape2)
library(stringr) 
```

# Loading dataframes and modifications
```{r}
# Loading dataframe(s)
#AllDataFrame <- load("data/Patch_And_Colony_Data_20201103.rdata")

#load updated dataframe
AllDataFrame <- load("data/Patch_And_Colony_Data_20210412.rdata")

```

```{r}
# Ensuring that the log size values are numbers (I think they are numeric, but maybe not!)
# And that the -Infs are NAs instead
# ColonyLevel$ln_ESc <- as.numeric(ColonyLevel$ln_ESc)
# ColonyLevel$ln_SS[ColonyLevel$ln_ESc == -Inf] <-NA
# 
# ColonyLevel$ln_SS <- as.numeric(ColonyLevel$ln_SS)
# ColonyLevel$ln_SS[ColonyLevel$ln_SS == -Inf] <-NA

#changing ln_ES/ln_SS from Na/-Inf to an actual value for recruitment/mortality
ColonyLevel$ln_SS <- log(ColonyLevel$StartingSize)
ColonyLevel$ln_ES <- log(ColonyLevel$EndingSize)

# ColonyLevel$ln_ESc <- as.numeric(ColonyLevel$ln_ESc)
# ColonyLevel$ln_SS[ColonyLevel$ln_ESc == -Inf] <-NA
# 
ColonyLevel$ln_SS <- as.numeric(ColonyLevel$ln_SS)
ColonyLevel$ln_SS[ColonyLevel$ln_SS == -Inf] <-NA

ColonyLevel <- cbind(ColonyLevel, data.frame(Survival = 
                                               1 - ColonyLevel$Mortality))

# Making the size term yearly
GY <- (ColonyLevel$ln_ES - ColonyLevel$ln_SS)*(1/ColonyLevel$Interval_Year)
ColonyLevel <- cbind(ColonyLevel, data.frame(ln_ESc = 
                                             ColonyLevel$ln_SS + GY))

# Defining site IDs, genera names, and transition intervals (years) as lists
SiteNames <- as.character(unique(ColonyLevel$Site))
GeneraNames <- as.character(unique(ColonyLevel$Genus_Code))
IntervalYears <- unique(ColonyLevel$Interval)
```


# Model parameterization
The aim of this analysis is to calculate the kernel fits (growth, survival, & reproduction) for each combination of genera-site-year and then each separately. 

## Full models:
(1) All terms together, no separation
(2) Each Genera for all sites & interval years
(3) Each Site for all genera & interval years
(4) Each Interval Year for all sites & genera

## Individual models: (the more realistic models that we are more interested in)
(5) Each Genera by interval year, sites are not separated
(6) Each Genera by site, interval years are not separated
(7) Each Site by interval year, genera not separated
(8) Each genera by site and interval year (we will have parameter values that equal site * interval years * genera)

_*these separations only apply to our growth and survival models, reproduction is not modeled this way_

```{r,}

surv_dat <- data.frame()
for (i in 1:nrow(ColonyLevel)){
  if(ColonyLevel$Survival[i] == 0){
    surv_dat <- rbind(surv_dat, data.frame(ColonyID = ColonyLevel$ColonyID[i], 
                                size = ColonyLevel$ln_SS[i-1], survival = 0, 
                                Genus_Code = ColonyLevel$Genus_Code[i],
                                Interval = ColonyLevel$Interval[i],
                                SiteInterval = ColonyLevel$SiteInterval[i],
                                Site = ColonyLevel$Site[i])) 
  }
  else{
    surv_dat <- rbind(surv_dat, data.frame(ColonyID = ColonyLevel$ColonyID[i], 
                                size = ColonyLevel$ln_SS[i], survival = 1, 
                                Genus_Code = ColonyLevel$Genus_Code[i],
                                Interval = ColonyLevel$Interval[i],
                                SiteInterval = ColonyLevel$SiteInterval[i],
                                Site = ColonyLevel$Site[i]))}
}

```


```{r Interactions,}
###### Interactions code from Mike #############################################
## Functions to calculate the slope and intercepts from interactions ###########

interceptz <-function(mod, u_predict){ 
	int <- rep(coef(mod)[[1]], length(u_predict))
	for (i in 2:length(u_predict)) {
	  Name <- grepl(u_predict[i], 
	                names(coef(mod))) & !grepl(names(coef(mod))[2], 
	                                           names(coef(mod)))
	  if (sum(Name) == 0) int[i] <- NA
	  else {
	  int[i] <- int[i] + coef(mod)[Name]}}
	int} 
	
slopez <-function(mod, u_predict){ 
	slp <- rep(coef(mod)[[2]], length(u_predict))
	for (i in 2:length(u_predict)) { 
	  Name <- grepl(u_predict[i],
	                names(coef(mod))) & grepl(names(coef(mod))[2],
	                                          names(coef(mod)))
	  if (sum(Name) == 0) slp[i] <- NA
	  else {
	  slp[i] <- slp[i] + coef(mod)[Name]}}
	slp}


```

```{r}
################################################################################
# Model interactions by genus: Growth ##########################################
################################################################################
################################################################################

Growth <- subset(ColonyLevel, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")

# Only run this initially
# we will compare this to other models calculated separately 
dt               <- data.frame() # defining the full data frame
df_SiteYear_coef <- data.frame()
df_Year_coef     <- data.frame()
df_Site_coef     <- data.frame()

# Separating the growth data frame by genera #
POCS <- Growth[Growth$Genus_Code==GeneraNames[1],]
POSP <- Growth[Growth$Genus_Code==GeneraNames[2],]
MOSC <- Growth[Growth$Genus_Code==GeneraNames[3],]
```

```{r}
Choice <- MOSC # Change this to the Genera Name above that you care about

x2_S   <- sort(unique(Choice$Site)) # your second predictor
x2_Y   <- sort(unique(Choice$Interval)) # another predictor for time
x2_SY  <- sort(unique(Choice$SiteInterval)) # another predictor where time & site are together 

mod_site      <- lm(ln_ESc ~ ln_SS + Site + Site*ln_SS, data = Choice)
mod_year      <- lm(ln_ESc ~ ln_SS + Interval + Interval*ln_SS, data = Choice)
mod_site_year <- lm(ln_ESc ~ ln_SS + 
                      SiteInterval + SiteInterval*ln_SS, data = Choice)

dt <- rbind(dt, data.frame(ID=x2_S,
                           Genus_Code=rep(Choice$Genus_Code[1],length(x2_S)),
                           g.int=interceptz(mod_site, x2_S),
                           g.slp=slopez(mod_site, x2_S)))

dt <- rbind(dt, data.frame(ID=x2_Y, 
                           Genus_Code=rep(Choice$Genus_Code[1], length(x2_Y)),
                           g.int=interceptz(mod_year, x2_Y),
                           g.slp=slopez(mod_year, x2_Y)))

dt <- rbind(dt, data.frame(ID=x2_SY, 
                           Genus_Code=rep(Choice$Genus_Code[1], length(x2_SY)),
                           g.int=interceptz(mod_site_year, x2_SY),
                           g.slp=slopez(mod_site_year, x2_SY)))

df               <- as.data.frame(coef(summary(mod_site)))
df               <- cbind(df, data.frame(Genus_Code = rep(Choice$Genus_Code[1],
                                     dim(df["Estimate"])[1])))
df_Site_coef     <- rbind(df_Site_coef, df)


df               <- as.data.frame(coef(summary(mod_year)))
df               <- cbind(df, data.frame(Genus_Code = rep(Choice$Genus_Code[1],
                                     dim(df["Estimate"])[1])))
df_Year_coef     <- rbind(df_Year_coef, df)


df               <- as.data.frame(coef(summary(mod_site_year)))
df               <- cbind(df, data.frame(Genus_Code = rep(Choice$Genus_Code[1],
                                     dim(df["Estimate"])[1])))
df_SiteYear_coef <- rbind(df_SiteYear_coef, df)

```

```{r}
save(dt, file = "data/Growth_intmod_params.rdata")
save(df_Site_coef, file = "data/Growth_intmod_summary_site.rdata")
save(df_Year_coef, file = "data/Growth_intmod_summary_year.rdata")
save(df_SiteYear_coef, file = "data/Growth_intmod_summary_site_year.rdata")
```

```{r,}
################################################################################
# Model interactions by genus: Survival ########################################
################################################################################
# subsetting the survival data frame by genera 
POCS <- surv_dat[surv_dat$Genus_Code==GeneraNames[1],]
POSP <- surv_dat[surv_dat$Genus_Code==GeneraNames[2],]
MOSC <- surv_dat[surv_dat$Genus_Code==GeneraNames[3],]

# Initializing data frames to save model slopes and summaries
# Only run at beginning
dS               <- data.frame()
df_SiteYear_coef <- data.frame()
df_Year_coef     <- data.frame()
df_Site_coef     <- data.frame()
```

```{r}
# Change this each time for the different Genus Codes
# This just makes it into a generic name to change once in beginning & not have to change multiple times in the code
Choice <- MOSC

x2_S   <- sort(unique(Choice$Site)) # your second predictor
x2_Y   <- sort(unique(Choice$Interval)) # another predictor for time
x2_SY  <- sort(unique(Choice$SiteInterval)) # another predictor where time & site are together 

modS_site      <- glm(survival ~ size + Site + Site*size, 
                      family = "binomial", data = Choice)
modS_year      <- glm(survival ~ size + Interval + 
                        Interval*size, family = "binomial", data = Choice)
modS_site_year <- glm(survival ~ size + SiteInterval + 
                        SiteInterval*size, family = "binomial", data = Choice)

dS <- rbind(dS, data.frame(ID=x2_S,
                           Genus_Code=rep(Choice$Genus_Code[1],length(x2_S)),
                           s.int=interceptz(modS_site, x2_S),
                           s.slp=slopez(modS_site, x2_S)))

dS <- rbind(dS, data.frame(ID=x2_Y, 
                           Genus_Code=rep(Choice$Genus_Code[1], length(x2_Y)),
                           s.int=interceptz(modS_year, x2_Y),
                           s.slp=slopez(modS_year, x2_Y)))

dS <- rbind(dS, data.frame(ID=x2_SY, 
                           Genus_Code=rep(Choice$Genus_Code[1], length(x2_SY)),
                           s.int=interceptz(modS_site_year, x2_SY),
                           s.slp=slopez(modS_site_year, x2_SY)))

df               <- as.data.frame(coef(summary(modS_site)))
df               <- cbind(df, data.frame(Genus_Code = rep(Choice$Genus_Code[1],
                                     dim(df["Estimate"])[1])))
df_Site_coef     <- rbind(df_Site_coef, df)


df               <- as.data.frame(coef(summary(modS_year)))
df               <- cbind(df, data.frame(Genus_Code = rep(Choice$Genus_Code[1],
                                     dim(df["Estimate"])[1])))
df_Year_coef     <- rbind(df_Year_coef, df)


df               <- as.data.frame(coef(summary(modS_site_year)))
df               <- cbind(df, data.frame(Genus_Code = rep(Choice$Genus_Code[1],
                                     dim(df["Estimate"])[1])))
df_SiteYear_coef <- rbind(df_SiteYear_coef, df)
                        

```

```{r}
save(dS, file = "data/Survival_intmod_params.rdata")
save(df_Site_coef, file = "data/Survival_intmod_summary_site.rdata")
save(df_Year_coef, file = "data/Survival_intmod_summary_year.rdata")
save(df_SiteYear_coef, file = "data/Survival_intmod_summary_site_year.rdata")
```


```{r}
# modS <- glm(survival ~ size, family = "binomial" , data = surv_dat)
plot(jitter(survival, 0.1) ~ size, Choice)
ss <- seq(-3, 9, 0.1)
lines(ss, predict(modS_site[1], list(size = ss), type="response"), pch=8)

summary(modS_site)
summary(modS_year)
summary(modS_site_year)
drop1(modS_site_POCS, test="F")

modS_site_POSP <- glm(survival ~ size + Site, family = "binomial" , 
           data = ColonyLevel[ColonyLevel$Genus_Code == GeneraNames[2],])
summary(modS_site_POSP)
drop1(modS_site_POSP, test="F")

modS_site_MOSC <- glm(survival ~ size + Site, family = "binomial" , 
           data = ColonyLevel[ColonyLevel$Genus_Code == GeneraNames[3],])
summary(modS_site_MOSC)
drop1(modS_site_MOSC, test="F")
```



### Growth 

```{r 1 GeneraMod Growth,}
################################################################################
######### Genera models: Growth ################################################
################################################################################
  
# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- GeneraNames 
LoopLength <- length(Focus)
minTrans <- 30 # minimum number of transitions

growth <- matrix(0, nrow = 2, ncol = LoopLength)
note <- aic <- Var <- c()

GrowthDataFrame <- data.frame() #initialize 
for (i in 1:LoopLength){
  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])
  
  
  # subsetting for growth & shrinkage
  subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")
  
  ln_SS <- subset2$ln_SS
  ln_ESc <- subset2$ln_ESc
  
  # Saving growth model
  if (length(ln_SS) >= minTrans){
    mod <- lm(ln_ESc ~ ln_SS)
    note[i] <- sprintf("Num of transitions = %s", 
                    length(ln_SS))
    
    growth[,i] <- coef(mod)
    Var[i] <- (summary(mod)$sigma)**2
    aic[i] <- AIC(mod)
    }
  
  if (length(ln_SS) < minTrans){
    #setting values to NaNs
    note[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(ln_SS))
    growth[,i] <- NaN
    Var[i] <- NA
    aic[i] <- NA
    }
  
  # Row binding the model results into the growth model dataframe
  
  df <- data.frame(Model_IDs = sprintf("%s_All_Sites_n_Years",Focus[i]), 
                 g.int = growth[1,i], g.slp = growth[2,i], g.var = Var[i], 
                 AIC = aic[i], growth_notes = note[i])
  
  GrowthDataFrame <- rbind(GrowthDataFrame,df)
}


```
```{r 2 SiteMod Growth,}
################################################################################
######### Site models ##########################################################
################################################################################

# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- SiteNames 
LoopLength <- length(Focus)
minTrans <- 30 # minimum number of transitions

growth <- matrix(0, nrow = 2, ncol = LoopLength)
Var <- aic <- note <- c()

for (i in 1:LoopLength){
  subset1 <- subset(ColonyLevel, Site == Focus[i])
  
  # subsetting for growth & shrinkage
  subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")
  
  ln_SS <- subset2$ln_SS
  ln_ESc <- subset2$ln_ESc
  
  if (length(ln_SS) > minTrans){
    mod <- lm(ln_ESc ~ ln_SS)
    note[i] <- sprintf("Num of transitions = %s", length(ln_SS))
    
    growth[,i] <- coef(mod)
    Var[i] <- (summary(mod)$sigma)**2
    aic[i] <- AIC(mod)}
  
  if (length(ln_SS) <= minTrans){
    #setting values to NaNs
    note[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(ln_SS))
    growth[,i] <- NaN
    Var[i] <- NA
    aic[i] <- NA}

  # saving the growth model
  df <- data.frame(Model_IDs = sprintf("%s_All_Genera_n_Years",Focus[i]), 
                 g.int = growth[1,i], g.slp = growth[2,i], 
                 g.var = Var[i], AIC = aic[i], growth_notes = note[i])
  
  GrowthDataFrame <- rbind(GrowthDataFrame,df)
}

```
```{r 3 YearMod Growth,}
################################################################################
######### Interval Year models #################################################
################################################################################

# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- IntervalYears 
LoopLength <- length(Focus)
minTrans <- 30 # minimum number of colonies

growth <- matrix(0, nrow = 2, ncol = LoopLength)
Var <- note <- aic <- c()
 
for (i in 1:LoopLength){
  subset1 <- subset(ColonyLevel, Interval == Focus[i])
  
  # subsetting for growth & shrinkage
  subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")
  
  ln_SS <- subset2$ln_SS
  ln_ESc <- subset2$ln_ESc
  
  if (length(ln_SS) > minTrans){
    mod <- lm(ln_ESc ~ ln_SS)
    note[i] <- sprintf("Num of transitions = %s", length(ln_SS))
    
    growth[,i] <- coef(mod)
    Var[i] <- (summary(mod)$sigma)**2
    aic[i] <- AIC(mod)}
  
  if (length(ln_SS) <= minTrans){
    #setting values to NaNs
    note[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(ln_SS))
    growth[,i] <- NaN
    Var[i] <- NA
    aic[i] <- NA}
  
  df <- data.frame(Model_IDs = sprintf("%s_All_Genera_n_Sites",Focus[i]), 
                 g.int = growth[1,i], g.slp = growth[2,i], 
                 g.var = Var[i], AIC = aic[i], growth_notes = note[i])
  
  GrowthDataFrame <- rbind(GrowthDataFrame,df)
}

```
```{r 4 Genera + Site Mod Growth,}
################################################################################
######### Genera + Site for all Interval Years models: growth ##################
################################################################################

# define the parms for model loop
# Now with a second "Focus"
Focus <- GeneraNames
subFocus <- SiteNames
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of colonies
minTrans <- 30 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  growth <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  note <- Var <- aic <- c()
  
  # subset ColonyLevel to specify first focus
  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])
  
  for (v in 1:LoopLengthSF){
    # subsetting for growth & shrinkage
    subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                 TransitionTypeSimple == "SHRINK")
    
    # subsetting growth & shrinkage for second focus
    subset3 <- subset(subset2, Site == subFocus[v])
    
    ln_SS <- subset3$ln_SS
    ln_ESc <- subset3$ln_ESc
    
    if (length(ln_SS) > minTrans){
      mod <- lm(ln_ESc ~ ln_SS)
      note[v] <- sprintf("Num of transitions = %s", length(ln_SS))
      growth[,v] <- coef(mod)
      Var[v] <- (summary(mod)$sigma)**2
      aic[v] <- AIC(mod)}
    
    if (length(ln_SS) <= minTrans){
      #setting values to NaNs
      note[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(ln_SS))
      growth[,v] <- NaN
      Var[v] <- NA
      aic[v] <- NA}
    
  df <- data.frame(Model_IDs = sprintf("%s_%s_All_Years",Focus[i], subFocus[v]), 
                 g.int = growth[1,v], g.slp = growth[2,v], 
                 g.var = Var[v], AIC = aic[v], growth_notes = note[v])
  
  GrowthDataFrame <- rbind(GrowthDataFrame,df)
  
  }} 
 
```
```{r 5 Genera + Years Mod Growth,}
################################################################################
######### Genera + Interval Years for all Site models ##########################
################################################################################

# define the parms for model loop
# Now with a second "Focus"

Focus <- GeneraNames
subFocus <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of transitions
minTrans <- 30 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  growth <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  survival <- growth
  note <- Var <- aic <- c()
  Snote <- Var_S <- aic_S <- c()
  
  # subset data frames to specify first focus
  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])

  for (v in 1:LoopLengthSF){
    
    # subsetting for growth & shrinkage
    subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                 TransitionTypeSimple == "SHRINK")
    
    # subsetting growth & shrinkage for second focus
    subset3 <- subset(subset2, Interval == subFocus[v])
    
    ln_SS <- subset3$ln_SS
    ln_ESc <- subset3$ln_ESc

    if (length(ln_SS) > minTrans){
      mod <- lm(ln_ESc ~ ln_SS)
      note[v] <- sprintf("Num of transitions = %s", length(ln_SS))
      growth[,v] <- coef(mod)
      Var[v] <- (summary(mod)$sigma)**2
      aic[v] <- AIC(mod)}
    
    if (length(ln_SS) <= minTrans){
      #setting values to NaNs
      note[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(ln_SS))
      growth[,v] <- NaN
      Var[v] <- NA
      aic[v] <- NA}
    
    df <- data.frame(Model_IDs = sprintf("%s_%s_All_Sites",Focus[i], subFocus[v]), 
               g.int = growth[1,v], g.slp = growth[2,v], 
               g.var = Var[v], AIC = aic[v], growth_notes = note[v])
  
    GrowthDataFrame <- rbind(GrowthDataFrame,df)
  
}}
 
```
```{r 6 Site + Years Mod Growth,}
################################################################################
######### Site + Interval Years for all Genera models ##########################
################################################################################

# define the parms for model loop
# Now with a second "Focus"

Focus <-SiteNames
subFocus <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of transitions
minTrans <- 30 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  growth <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  survival <- growth
  note <- Var <- aic <- c()
  Snote <- Var_S <- aic_S <- c()
  
  # subset ColonyLevel to specify first focus
  subset1 <- subset(ColonyLevel, Site == Focus[i])


  for (v in 1:LoopLengthSF){
    
    # subsetting for growth & shrinkage
    subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                 TransitionTypeSimple == "SHRINK")
    
    # subsetting for Interval_Years
    subset3 <- subset(subset2, Interval == subFocus[v])
    
    ln_SS <- subset3$ln_SS
    ln_ESc <- subset3$ln_ESc
    
    if (length(ln_SS) > minTrans){
      mod <- lm(ln_ESc ~ ln_SS)
      note[v] <- sprintf("Num of transitions = %s", length(ln_SS))
      growth[,v] <- coef(mod)
      Var[v] <- (summary(mod)$sigma)**2
      aic[v] <- AIC(mod)}
    
    if (length(ln_SS) <= minTrans){
      #setting values to NaNs
      note[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(ln_SS))
      growth[,v] <- NaN
      Var[v] <- NA
      aic[v] <- NA}
    
    # saving growth model 
    
    df <- data.frame(Model_IDs = sprintf("%s_%s_All_Genera",Focus[i], subFocus[v]), 
             g.int = growth[1,v], g.slp = growth[2,v], 
             g.var = Var[v], AIC = aic[v], growth_notes = note[v])
  
    GrowthDataFrame <- rbind(GrowthDataFrame,df)
  }}
```
```{r 7 Genera + Site + Years Mod Growth,}
################################################################################
######### Genera + Site + Interval Years  models ###############################
########## GROWTH ! ############################################################
################################################################################
# define the parms for model loop
# Now with a second "Focus"

Focus <- GeneraNames
subFocus <- SiteNames
subFocus2 <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)
LoopLengthSF2 <-  length(subFocus2)

minTrans <- 30 

for (i in 1:LoopLength){
  
  # subset Genus_Code for specific genera
  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])

  for (v in 1:LoopLengthSF){
    
    # redefine the matrix for each Focus step
    growth <- matrix(0, nrow = 2, ncol = LoopLengthSF2)
    note <- Var <- aic <- c()
    
    # subsetting for growth & shrinkage
    subset2 <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                 TransitionTypeSimple == "SHRINK")
    
    # subsetting growth & shrinkage for specific Site
    subset3 <- subset(subset2, Site == subFocus[v])
    
    for (y in 1:LoopLengthSF2){
      
      #subsetting genera specific & Site specific into interval year specific
      subset4 <- subset(subset3, Interval == subFocus2[y])
      
      ln_SS <- subset4$ln_SS
      ln_ESc <- subset4$ln_ESc
      
      if (length(ln_SS) > minTrans){
        mod <- lm(ln_ESc ~ ln_SS)
        note[y] <- sprintf("Num of transitions = %s", length(ln_SS))
        growth[,y] <- coef(mod)
        Var[y] <- (summary(mod)$sigma)**2
        aic[y] <- AIC(mod)}
      
      if (length(ln_SS) <= minTrans){
        #setting values to NaNs
        note[y] <- sprintf("Not enough data. Num transitions = %s", 
                        length(ln_SS))
        growth[,y] <- NaN
        Var[y] <- NA
        aic[y] <- NA}
      
      df <- data.frame(Model_IDs = sprintf("%s_%s_%s",Focus[i], 
                                           subFocus[v], subFocus2[y]), 
                 g.int = growth[1,y], g.slp = growth[2,y], 
                 g.var = Var[y], AIC = aic[y], growth_notes = note[y])
      
      GrowthDataFrame <- rbind(GrowthDataFrame,df)
}}}

```

### Survival

```{r 1 GeneraMod Survival,}
################################################################################
######### Genera models: Survival ##############################################
################################################################################
SurvivalDataFrame <- data.frame()

Focus <- GeneraNames 
LoopLength <- length(Focus)
minTrans <- 30 # minimum number of transitions
survival <- matrix(0, nrow = 2, ncol = LoopLength)
Snote <- aic_S  <- c()

for (i in 1:LoopLength){
  subset1_S <- subset(ColonyLevel, Genus_Code == Focus[i])
# Saving survival model
  
  if (length(subset1_S$size) >= minTrans){
    modS <- glm(survival ~ size, family = "binomial" , data = subset1_S)
    Snote[i] <- sprintf("Num of transitions = %s", 
                    length(subset1_S$size))
    
    survival[,i] <- coef(modS)
    aic_S[i] <- AIC(modS)
    }
  
  if (length(subset1_S$size) < minTrans){
    #setting values to NaNs
    Snote[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(subset1_S$size))
    survival[,i] <- NaN
    aic_S[i] <- NA
  }
  
  # Row binding the model results into the growth model dataframe
  
  dfS <- data.frame(Model_IDs = sprintf("%s_All_Sites_n_Years",Focus[i]), 
                                s.int = survival[1,i], s.slp = survival[2,i], 
                                AIC = aic_S[i], survival_notes = Snote[i])
  
  SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
  
}

# the model does converge here  

 
```
```{r 2 SiteMod Survival,}
################################################################################
######### Site models: Survival ################################################
################################################################################

# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- SiteNames 
LoopLength <- length(Focus)
minTrans <- 30 # minimum number of transitions

survival <- matrix(0, nrow = 2, ncol = LoopLength)
Snote <- aic_S <- c()

for (i in 1:LoopLength){
  subset1_S <- subset(ColonyLevel, Site == Focus[i])
  
  if (length(subset1_S$size) >= minTrans){
    modS <- glm(survival ~ size, family = "binomial" , data = subset1_S)
    Snote[i] <- sprintf("Num of transitions = %s", 
                    length(subset1_S$size))
    
    survival[,i] <- coef(modS)
    aic_S[i] <- AIC(modS)
    }
  
  if (length(subset1_S$size) < minTrans){
    #setting values to NaNs
    Snote[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(subset1_S$size))
    survival[,i] <- NaN
    Var_S[i] <- NA
    aic_S[i] <- NA
    }
  

 # Row binding the model results into the growth model dataframe
  
  dfS <- data.frame(Model_IDs = sprintf("%s_All_Genera_n_Years",Focus[i]), 
                                s.int = survival[1,i], s.slp = survival[2,i], 
                                AIC = aic_S[i], survival_notes = Snote[i])
  
  SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
  }

## Getting the error: "glm.fit: algorithm did not converge" might need to start this loop with a new dataframe for the survival data? 
```
```{r 3 YearMod Survival,}
################################################################################
########## Interval Year models: survival ######################################
################################################################################

# initializing the data runs for the growth analysis
# define the parms for model loop
Focus <- IntervalYears 
LoopLength <- length(Focus)
minTrans <- 30 # minimum number of colonies

survival <- matrix(0, nrow = 2, ncol = LoopLength)
Snote <- aic_S <- c()

for (i in 1:LoopLength){
  subset1_S <- subset(ColonyLevel, Interval == Focus[i])
  
   # Survival model 
  if (length(subset1_S$size) >= minTrans){
    modS <- glm(survival ~ size, family = "binomial" , data = subset1_S)
    Snote[i] <- sprintf("Num of transitions = %s", 
                    length(subset1_S$size))
    
    survival[,i] <- coef(modS)
    aic_S[i] <- AIC(modS)
    }
  
  if (length(subset1_S$size) < minTrans){
    #setting values to NaNs
    Snote[i] <- sprintf("Not enough data. Num transitions = %s", 
                    length(subset1_S$size))
    survival[,i] <- NaN
    aic_S[i] <- NA
    }
  

  # Row binding the model results into the growth model dataframe
  
  dfS <- data.frame(Model_IDs = sprintf("%s_All_Genera_n_Sites",Focus[i]), 
                                s.int = survival[1,i], s.slp = survival[2,i], 
                                AIC = aic_S[i], survival_notes = Snote[i])
  
  SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
  
}

## Getting the error: "glm.fit: algorithm did not converge" might need to start this loop with a new dataframe for the survival data? 
```
```{r 4 Genera + Site Mod Survival,}
################################################################################
######### Genera + Site for all Interval Years models: survival ################
################################################################################

# define the parms for model loop
Focus <- GeneraNames
subFocus <- SiteNames
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of colonies
minTrans <- 30 

for (i in 1:LoopLength){
  survival <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  Snote <- aic_S <- c()

  subset1_S <- ColonyLevel[ColonyLevel$Genus_Code == Focus[i],]

  for (v in 1:LoopLengthSF){
    #v = 8
    subset2_S <- subset1_S[subset1_S$Site == subFocus[v],]
    
    if (nrow(subset2_S) == 0){
      #setting values to NaNs
    Snote[v] <- sprintf("No data for %s and %s", Focus[i], subFocus[v])
    survival[,v] <- NaN
    aic_S[v] <- NA
    }
    
    if (length(subset2_S$size) >= minTrans){
    modS <- glm(survival ~ size, family = "binomial" , data = subset2_S)
    Snote[v] <- sprintf("Num of patches = %s", 
                    length(subset2_S$size))
    
    survival[,v] <- coef(modS)
    aic_S[v] <- AIC(modS)
    }
  
  if (length(subset2_S$size) < minTrans){
    #setting values to NaNs
    Snote[v] <- sprintf("Not enough data. Num patches = %s", 
                    length(subset2_S$size))
    survival[,v] <- NaN
    aic_S[v] <- NA
    }
  
  
  dfS <- data.frame(Model_IDs = sprintf("%s_All_Years",Focus[v]), 
                                s.int = survival[1,v], s.slp = survival[2,v], 
                                AIC = aic_S[v], survival_notes = Snote[v])
  
  SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
   
   
  }
}

```
```{r 5 Genera + Years Mod Survival,}
################################################################################
######### Genera + Interval Years for all Site models ##########################
################################################################################

# define the parms for model loop
# Now with a second "Focus"

Focus <- GeneraNames
subFocus <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of transitions
minTrans <- 30 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  survival <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  Snote <- aic_S <- c()
  
  # subset data frames to specify first focus
  subset1_S <- subset(ColonyLevel, Genus_Code == Focus[i])

  for (v in 1:LoopLengthSF){

    # subsetting growth & shrinkage for second focus
    subset2_S <- subset(subset1_S, Interval == subFocus[v])
    
    # Survival model 
    if (length(subset2_S$size) >= minTrans){
      modS <- glm(survival ~ size, family = "binomial" , data = subset2_S)
      Snote[v] <- sprintf("Num of transitions = %s", 
                      length(subset2_S$size))
      
      survival[,v] <- coef(modS)
      aic_S[v] <- AIC(modS)
      }
    
    if (length(subset2_S$size) < minTrans){
      #setting values to NaNs
      Snote[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(subset2_S$size))
      survival[,v] <- NaN
      aic_S[v] <- NA
      }
    
  
    # Row binding the model results into the growth model dataframe
    
    dfS <- data.frame(Model_IDs = sprintf("%s_All_Sites",Focus[v]), 
                                  s.int = survival[1,v], s.slp = survival[2,v], 
                                  AIC = aic_S[v], survival_notes = Snote[v])
    
    SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
  }

}

```
```{r 6 Site + Years Mod Survival,}
################################################################################
######### Site + Interval Years for all Genera models ##########################
################################################################################

# define the parms for model loop
# Now with a second "Focus"

Focus <-SiteNames
subFocus <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)

# setting minimum number of transitions
minTrans <- 30 

for (i in 1:LoopLength){
  
  # redefine the matrix for each Focus step
  survival <- matrix(0, nrow = 2, ncol = LoopLengthSF)
  Snote<- aic_S <- c()
  
  # subset ColonyLevel to specify first focus
  subset1 <- subset(ColonyLevel, Site == Focus[i])

  for (v in 1:LoopLengthSF){
    
    # subsetting for Interval
    subset2_S <- subset(subset1_S, Interval == subFocus[v])

    # Survival model 
    if (length(subset2_S$size) >= minTrans){
      modS <- glm(survival ~ size, family = "binomial" , data = subset2_S)
      Snote[v] <- sprintf("Num of transitions = %s", 
                      length(subset2_S$size))
      
      survival[,v] <- coef(modS)
      aic_S[v] <- AIC(modS)
      }
    
    if (length(subset2_S$size) < minTrans){
      #setting values to NaNs
      Snote[v] <- sprintf("Not enough data. Num transitions = %s", 
                      length(subset2_S$size))
      survival[,v] <- NaN
      aic_S[v] <- NA
      }
    
  
    # Row binding the model results into the survival model dataframe
    
    dfS <- data.frame(Model_IDs = sprintf("%s_All_Genera",Focus[v]), 
                                  s.int = survival[1,v], s.slp = survival[2,v], 
                                  AIC = aic_S[v], survival_notes = Snote[v])
    
    SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
     
  
  }

}


```
```{r 7 Genera + Site + Years Mod Survival,}
################################################################################
######### Genera + Site + Interval Years  models ###############################
## SURVIVAL ! ##################################################################
################################################################################
# define the parms for model loop
# Now with a second "Focus"

Focus <- GeneraNames
subFocus <- SiteNames
subFocus2 <- IntervalYears
LoopLength <- length(Focus)
LoopLengthSF <-  length(subFocus)
LoopLengthSF2 <-  length(subFocus2)

minTrans <- 30 

for (i in 1:LoopLength){
  
  # subset Genus_Code for specific genera
  subset1_S <- subset(ColonyLevel, Genus_Code == Focus[i])

  for (v in 1:LoopLengthSF){
    
    # redefine the matrix for each Focus step
    survival <- matrix(0, nrow = 2, ncol = LoopLengthSF2)
    Snote <- aic_S <- c()
    
    #subsetting genera specific into Site specific
    subset2_S <- subset(subset1_S, Site == subFocus[v])
    
    for (y in 1:LoopLengthSF2){
      #subsetting genera specific & Site specific into interval year specific
      subset3_S <- subset(subset2_S, Interval == subFocus2[y])

# Survival model 
    if (length(subset3_S$size) >= minTrans){
      modS <- glm(survival ~ size, family = "binomial" , data = subset3_S)
      Snote[y] <- sprintf("Num of transitions = %s", 
                      length(subset3_S$size))
      
      survival[,y] <- coef(modS)
      aic_S[y] <- AIC(modS)
      }
    
    if (length(subset3_S$size) < minTrans){
      #setting values to NaNs
      Snote[y] <- sprintf("Not enough data. Num transitions = %s", 
                      length(subset3_S$size))
      survival[,y] <- NaN
      aic_S[y] <- NA
      }
    
  
    # Row binding the model results into the survival model dataframe
    
    dfS <- data.frame(Model_IDs = sprintf("%s_%s_%s",Focus[i], 
                                           subFocus[v], subFocus2[y]), 
                                  s.int = survival[1,y], s.slp = survival[2,y], 
                                  AIC = aic_S[y], survival_notes = Snote[y])
    
    SurvivalDataFrame <- rbind(SurvivalDataFrame,dfS)
      
    }}}

```

### Reproduction
Work in progress. 
```{r RecruitmentMods, eval=TRUE}
# Sepearting by genera
POCS <- ColonyLevel[ColonyLevel$Genus_Code==GeneraNames[1],]
POSP <- ColonyLevel[ColonyLevel$Genus_Code==GeneraNames[2],]
MOSC <- ColonyLevel[ColonyLevel$Genus_Code==GeneraNames[3],]
```

```{r}
Choice <- POCS

Tc   <- 1.0 # time cut off for sampling period obviously change value to reflect reality
Cutz <- which(Choice$Interval_Years < Tc) # returns index for sampling periods less than Tc

# Converting too small sampling periods into NAs to eliminate additional zeros
Choice$Recruit[Cutz] <- NA

Ints  <- unique(Choice$Interval)
times <- c()
recs  <- c()
for (i in 1:length(Ints)){
  a_recs  <- Choice$Recruit[which(Choice$Interval == Ints[i])]
  times   <- round(Choice$Interval_Years[which(Choice$Interval == Ints[i])])
  recs[i] <- sum(a_recs/times)
}

dr <- data.frame()
dr <- rbind(dr,data.frame(ID=rep(Choice$Genus_Code[1],length(recs)),
                  Tots_recs_peryear=recs,
                  Times=Ints,
                  Sites=rep('allSites',length(recs))))

# Need to run for sites & combination of site and time for the matricies for each genera
# Also need to make this clean


```

```{r}
# define the parms for model loop
Focus <- GeneraNames 
LoopLength <- length(Focus)

recruit_genera <- matrix(NaN, nrow = length(IntervalYears), ncol = LoopLength)

# These all depend on the interval years so it doesn't totally makes sense to get a model for that since we want a yearly recruitment rate.

# Calculate the rec vals for each genera at all sites
# Separate each genera 
# - for each unique interval year, take the sum of the area before recuritment (StartingSize)
# - get the num of recurites for each unique interval year
# - num rec / area * interval year (recruit/area*year)
# - should have 3 numbers
# Can leave it as vector for interval years or take an average...?

for (i in 1:LoopLength){

  subset1 <- subset(ColonyLevel, Genus_Code == Focus[i])
  
  #calculate unique time intervals
  timeint_all <- unique(subset1$Interval_Years)
  
  rec <- c()
  area <- rep(0,length(timeint_all)) #initalize vector
  for (w in 1:length(timeint_all)){
  area[w] <- sum(subset1$StartingSize[which(subset1$Interval_Years ==
                                              timeint_all[w])])
  if (area[w] == 0) area[w]<- NA
  rec[w] <- sum(subset1$Recruit[which(subset1$Interval_Years ==
                                              timeint_all[w])])}
  
  rec <- rec / area * timeint_all # this is the number multiplied by the total area at each time step to give the number of recurits at the following time step.
  
  recruit_genera[(1:length(rec)),i] <- rec
}

# Calculate the rec vals for each site all genera together
# -similar process as above, should have 11 #s
# define the parms for model loop
Focus <- SiteNames 
LoopLength <- length(Focus)

recruit_site <- matrix(NaN, nrow = length(IntervalYears), ncol = LoopLength)
for (i in 1:LoopLength){

  subsetz <- subset(ColonyLevel, Site == Focus[i])
  
  #calculate unique time intervals
  timeint_all <- unique(subsetz$Interval_Years)
  
  rec <- c()
  area <- rep(0,length(timeint_all)) #initalize vector
  for (w in 1:length(timeint_all)){
  area[w] <- sum(subsetz$StartingSize[which(subsetz$Interval_Years ==
                                              timeint_all[w])])
  if (area[w] == 0) area[w]<- NA
  rec[w] <- sum(subsetz$Recruit[which(subsetz$Interval_Years ==
                                              timeint_all[w])])}
  
  rec <- rec / area * timeint_all # this is the number multiplied by the total area at each time step to give the number of recurits at the following time step.
  
  recruit_site[(1:length(rec)),i] <- rec
}
# Calculate the rec vals for each site and each genera there
# - similar to before but with 33 possible values (not all sites had recruits for some genera)
Focus <- GeneraNames
subFocus <- SiteNames
LoopLength <- length(Focus)
LoopLengthSF <- length(subFocus)

recruit_sitegenera <- data.frame()

for (t in 1:LoopLength){
  recruit <- matrix(NaN, nrow = length(IntervalYears), ncol = LoopLengthSF)
  
  subseta <- subset(ColonyLevel, Genus_Code == Focus[t])
  
  for( i in 1:LoopLengthSF){
    
    subsetz <- subseta[subseta$Site == subFocus[i],]
    #calculate unique time intervals
    timeint_all <- unique(subsetz$Interval_Years)
    
    rec <- c()
    area <- rep(0,length(timeint_all)) #initalize vector
    
    if (nrow(subsetz) == 0) rec <- NaN
    
    else{  
      rec[w] <- sum(subsetz$Recruit[which(subsetz$Interval_Years ==
                                                timeint_all[w])])
      for (w in 1:length(timeint_all)){
      area[w] <- sum(subsetz$StartingSize[which(subsetz$Interval_Years ==
                                                timeint_all[w])])
      }
      rec <- rec / area * timeint_all
    }
     # this is the number multiplied by the total area at each time step to give the number of recurits at the following time step.
    
    recruit[(1:length(rec)),i] <- rec
  }
  recruit_sitegenera <- rbind(recruit_sitegenera, data.frame(Genus_Code = GeneraNames[t], rec_info = recruit))
}
View(recruit_sitegenera)

```


Testing the model interactions. Maybe this makes more sense to have earlier on the page but this is here for reference as to why we coded the models this way. We were interested in extracting the values for the IPM parameters.




```{r Basic IPMs}

options(stringsAsFactors=FALSE)

# Global mesh variables 

min.size <- -2.7  # 2*sqrt((10^-2.7)/pi)  # approx 5 cm  diameter coral
max.size <- 2     # 2*sqrt((10^2)/pi)     # approx 11 m diameter coral (ridiculous, but avoids boundary issues)
rec.size <- -2.5  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral

inv.logit <- function(x) {
  exp(x)/(1+exp(x))
}

################################################################################
###### The growth model ########################################################
################################################################################

growth_function <- function(y, x, g.int, g.slp, g.var) {
  mu <- (g.int + g.slp * x)
  sig <- sqrt(g.var)
  dnorm(y, mean=mu, sd=sig)
}

################################################################################
###### The survival model ######################################################
################################################################################

survival_function <- function(x, s.int, s.slp) {
  u <- inv.logit(s.int + s.slp * x) # From binomial glm, link = logit function
  # removed bakground mortality due to temp. 
  # Could add something in to add more stochasiticity?
}
################################################################################
###### The reproduction model ##################################################
################################################################################

reproduction_function <- function(y, x, rec, rec.size=-2.5) {
  # 2*sqrt((10^-2.5)/pi)  # approx 6 cm  diameter coral
  out <-  (10^x) * rec
  out[x < rec.size | y >= rec.size] <- 0 #if x is below recruitment size then it doesn't count 
  return(out)
}

################################################################################
########## ... Running the IPM ... #############################################
################################################################################
bigmatrix <- function(ModelParameters) {
  rec <- ModelParameters$rec
  g.int <- ModelParameters$g.int
  g.slp <- ModelParameters$g.slp
  g.var <- ModelParameters$g.var
  s.int <- ModelParameters$s.int
  s.slp <- ModelParameters$s.slp
  
  Reproduction_kernel <- delta_size * 
    outer(y, y, reproduction_function, 
          rec = "[Insert the rec value from models]")
  
  Growth_kernel <- delta_size * outer(y, y, growth_function, g.int=g.int, 
                                      g.slp=g.slp, g.var=g.var)
  Survival_kernel <- outer(y, survival_function, s.int=s.int, s.slp=s.slp)
  
  P <- Growth_kernel
  i <- 1:n_individuals
  P[,i] <- Growth_kernel[,i]*Survival_kernel[i]
  
  K <- P + Reproduction_kernel
  
  lam <- Re(eigen(K)$values[1])
  v <- Re(eigen(K)$vectors[,1])
  v <- v/sum(v) # right eigenvector/stable distribution
  
  return(list(K=K, lam=lam, v=v))
}
```

#Recruitment bar plots
All sites. Each site, all the interval years. Avg those values to get std deviation. That will be error bars
So bar for each site and timepoint. Avg the time points so get one bar per site.
If there's large error bars, there are certain years w/ large recruitment

Loop for each genus
Sub loop for site (take the avg of interval years)
Run sub loop through intervals (14-15) and get the sum of recruits
create an empty vector c() that has avg and another that has std error
should get whole numbers
Vector of integers that is the length of the total # of intervals sampled at that site (2 for 2 timepoints)
Bar will be avg recruitment per site

#Bar plots for reproduction
```{r,}
allrecs <- data.frame()

for (i in 1:length(GeneraNames)){
  ByGen <- subset(ColonyLevel, Genus_Code == GeneraNames[i])
  site <-  unique(ByGen$Site)
  for (l in 1:length(site)) {
    recs <- c()
    l = 1
    intz <- unique(ByGen$Interval)
    
    recs[l] <- sum(ByGen$Recruit[which(ByGen$Site == site[l])])
    allrecs <- rbind(allrecs, data.frame(Genera = sprintf("%s", GeneraNames[i]),
                                         siteInterval=sprintf("%s", siteInt[l]),
                                         rec_vals = recs[l]))
  }}

barplot(allrecs[allrecs$Genera == GeneraNames[1],][[3]], width = 0.5,
        names.arg = allrecs[allrecs$Genera == GeneraNames[1],][[2]], 
        main = GeneraNames[1], ylab = "Total recruits")

barplot(allrecs[allrecs$Genera == GeneraNames[2],][[3]], width = 0.5,
        names.arg = allrecs[allrecs$Genera == GeneraNames[2],][[2]],
        main = GeneraNames[2], ylab = "Total recruits")

barplot(allrecs[allrecs$Genera == GeneraNames[3],][[3]], width = 0.5,
        names.arg = allrecs[allrecs$Genera == GeneraNames[3],][[2]],
        main = GeneraNames[3], ylab = "Total recruits")

```


```{r}
#if the time interval is less than 1 year, need to drop them!!!

# sum number of recruits/site

recruit_bar <- data.frame()

for (i in 1:length(GeneraNames)){
  subsetz1 <- subset(ColonyLevel, Genus_Code == GeneraNames[i])

  for (l in 1:length(SiteNames)) {
    subsetz2 <- subsetz1[subsetz1$Site == SiteNames[i],]

    timeint <- unique(subsetz2$Interval)
    numbrecruits <- c()
    
    for (w in 1:length(timeint)){
      numbrecruits[w] <- sum(subsetz2$Recruit[which(subsetz2$Interval ==
                                            timeint[w])])
    }
    print(numbrecruits)
    print(timeint)
    
    # cat <- data.frame(ID=sprintf("%s_%s",GeneraNames[i],SiteNames[l]), Mean = 
    #                     mean(numbrecruits), 
    #                   StdError= sd(numbrecruits)/sqrt(length(numbrecruits)))
    # recruit_bar <- rbind(recruit_bar,cat)
  }
}


  for (i in 1:length(SiteNames)){
  recruit_bar <- matrix(NaN, nrow = length(IntervalYears), ncol = length(SiteNames))
  subsetz <- subset(ColonyLevel, Site == SiteNames[i])
  
  #calculate unique time intervals
  timeint_all <- unique(subsetz$Interval_Years)
  #for every interval year, get the sum of the number of recruits
  rec <- c()
  numbrecruits <- rep(0,length(timeint_all)) #initalize vector
  for (w in 1:length(timeint_all)){
  numbrecruits[w] <- sum(subsetz$Recruit[which(subsetz$Interval_Years ==
                                              timeint_all[w])])
  if (numbrecruits[w] == 0) numbrecruits[w]<- NA
  }
  
  rec <- numbrecruits * timeint_all # this is the # of recruits at each time step to give the number of recurits at the following time step.
  
  recruit_bar[(1:length(rec)),i] <- rec
  
  #row bind results into recruit #s dataframe
  rec_bar <- rbind(recruit_bar, data.frame(SiteName = SiteNames[i]))
}
View(recruit_bar)

```



#Plot matrix visualization
Rows=site
Column = Interval
cell values: growth intercept, growth slope, survival intercept, survival slope, recruitment (not sure)
```{r}
#example
ggplot(ColonyLevel, aes(x=Interval, y=Site))+
  geom_raster(aes(fill =Recruit ))+
  scale_fill_gradient(low = "grey90", high = "purple" )+
  labs(title = "Matrix visualization example")+
  theme_bw()

Basil <- str_split_fixed(GrowthDataFrame$Model_IDs,"_",2)
View(Basil)
GrowthDataFrame %>%
  separate(Model_IDs, c(), "_" )

#do we need to add a Site, Time Interval, and Genus column to GrowthDataFrame?!?
#Site = sprintf("%s",Focus[i]), TimeInterval = sprintf("%s",subFocus[v]),

#use lines 88-197 in GrowthDataFrame (growth model6 site and interval). Change fill to g.int
#ggplot(GrowthDataFrame, aes(x=????, y=?????))+
  geom_raster(aes(fill =g.int ))+
  scale_fill_gradient(low = "grey90", high = "purple" )+
  labs(title = "Matrix visualization example")+
  theme_bw()

```


#Plot full growth model and Genera model
```{r Plotting full growth model 1, }
allgrowth <- subset(subset1, TransitionTypeSimple == "GROWTH" | 
                   TransitionTypeSimple == "SHRINK")

#Plot full growth model
plot(ln_ESc ~ ln_SS ,data = allgrowth, main="Full growth fit")
abline(a=GrowthDataFrame$g.int[1], b=GrowthDataFrame$g.slp[1], col='red', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("red"),
       legend= 'All Growth' , cex = 0.8)



#Plot genera model (growth)
plot(ln_ESc ~ ln_SS ,data = allgrowth, main="Genera growth fit at all sites+ all interval years")
abline(a=GrowthDataFrame$g.int[2], b=GrowthDataFrame$g.slp[2], col='red', lwd=2)
abline(a=GrowthDataFrame$g.int[3], b=GrowthDataFrame$g.slp[3], col='blue', lwd=2)
abline(a=GrowthDataFrame$g.int[4], b=GrowthDataFrame$g.slp[4], col='green', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("red","blue","green"),
       legend= GeneraNames , cex = 0.8)


#plot each genus separately
par(mfrow=c(1,3))
#Pocillopora
plot(ln_ESc ~ ln_SS ,data = allgrowth,
     main="Pocillopora growth fit at all sites+ all interval years")
abline(a=GrowthDataFrame$g.int[2], b=GrowthDataFrame$g.slp[2], col='red', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("red"),
       legend= 'POCS' , cex = 0.8)
#Porites
plot(ln_ESc ~ ln_SS ,data = allgrowth, 
     main="Porites growth fit at all sites+ all interval years")
abline(a=GrowthDataFrame$g.int[3], b=GrowthDataFrame$g.slp[3], col='blue', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("blue"),
       legend= 'POSP' , cex = 0.8)
#Montipora
plot(ln_ESc ~ ln_SS ,data = allgrowth, 
     main="Montipora growth fit at all sites+ all interval years")
abline(a=GrowthDataFrame$g.int[4], b=GrowthDataFrame$g.slp[4], col='green', lwd=2)
legend("topleft", bty = "n", lty = c(1,1), col = c("green"),
       legend= 'MOSP' , cex = 0.8)

```
#Plotting full growth model 3: Sites
```{r Plotting full growth model3 Sites,}

#Plot full growth model2
LoopLeng <- length(SiteNames)
plot(ln_ESc ~ ln_SS ,data = allgrowth, 
     main="Each site growth fit for all genera + all interval years")
for (i in 1:LoopLeng) {
  abline(a=GrowthDataFrame$g.int[i], b=GrowthDataFrame$g.slp[i], col=i , lwd=2)
}
legend("topleft", bty = "n", lty = c(1,1), col = 1:11,
       legend= SiteNames , cex = 0.8, pt.cex = .7)


#plot each site's growth model separately
par(mfrow=c(4,3))
for (h in 1:LoopLeng) {
  plot(ln_ESc ~ ln_SS ,data = allgrowth, main="Each site growth fit for all genera + all interval years")
    abline(a=GrowthDataFrame$g.int[h], b=GrowthDataFrame$g.slp[h], col=h , lwd=2)
  legend("topleft", bty = "n", lty = c(1,1), col = h,
         legend= SiteNames[h], cex = 0.6, pt.cex = .5)
}

```

#Plot full growth model 4: Interval Years
Each Interval Year for all sites & genera
```{r Plotting full growth model 4,}
#Plot full growth model4
#mad right now bc of NA values
LoopL <- length(IntervalYears)
plot(ln_ESc ~ ln_SS ,data = allgrowth, 
     main="Each interval growth fit for all genera + all sites")
for (m in 1:LoopL) {
  abline(a=GrowthDataFrame$g.int[m], b=GrowthDataFrame$g.slp[m], col=m , lwd=2)
}
legend("topleft", bty = "n", lty = c(1,1), col = 1:11,
       legend= IntervalYears, cex = 0.8, pt.cex = .7)


#which(is.na(Glist_years$g.slp)) #in which index is the glope NA?
#why does interval year 4.26557 have a negative slope?
#ColonyLevel$Site[ColonyLevel$Interval_Years == IntervalYears[10]] #ID the site that is in the 10th position in IntervalYears

#plot each site's growth model separately
par(mfrow=c(4,3))
for (c in 1:LoopL) {
  plot(ln_ESc ~ ln_SS ,data = allgrowth, 
       main="Each interval growth fit for all genera + all sites")
    abline(a=GrowthDataFrame$g.int[c], b=GrowthDataFrame$g.slp[c], col=c , lwd=2)
  legend("topleft", bty = "n", lty = c(1,1), col = c,
         legend= IntervalYears[c], cex = 0.6, pt.cex = .5)
}

```

#Plot full growth model 5: Genera + Site (Work in progress)
Each Interval Year for Sites + Genera
```{r Plotting full growth model 4,}
#loop first for sites. Plot 11 sites
#next loop is from those specific genera at those specific sites


#Plot full growth model5
Loop1 <- length(GeneraNames)
Subloop1 <- length(SiteNames)

plot(ln_ESc ~ ln_SS ,data = allgrowth, 
     main="Each interval year for genera + site")
for (m in 1:Loop1) {
  abline(a=GrowthDataFrame$g.int[m], b=GrowthDataFrame$g.slp[m], col=m , lwd=2)
}
legend("topleft", bty = "n", lty = c(1,1), col = 1:11,
       legend= IntervalYears, cex = 0.8, pt.cex = .7)




#plot each site's growth model separately
par(mfrow=c(4,3))
for (c in 1:LoopL) {
  plot(ln_ESc ~ ln_SS ,data = allgrowth, 
       main="Each interval growth fit for all genera + all sites")
    abline(a=GrowthDataFrame$g.int[c], b=GrowthDataFrame$g.slp[c], col=c , lwd=2)
  legend("topleft", bty = "n", lty = c(1,1), col = c,
         legend= IntervalYears[c], cex = 0.6, pt.cex = .5)
}

```


#TO DO
[X] Run growth individual models 4-6
[X] Plot each genus separately (full growth model)
[X] Plot full growth model 2&3
[X] Figure out how to save into dataframe
[ ] Clean up script
[ ] Make powerpoint with some of our script and the plots
#Caroline
[ ] Fix growth plots (changed from list to df)
[ ] Plot survival models
[ ] Operationalize reprodution script
[ ] Plot reproduction models
[ ] Plot each individual growth model
#Devynn
[X] Add in survival to models 1-7
[X] Add AIC calcs into the dataframe
[X] Add variance into the dataframe
[X] Maybe add reproduction into models 1-7?
[X] Start IPM chunk set up
[ ] Put everything into a dataframe
[ ] Run Growth Models with standardized sizes
[ ] Figure out issues with survival




#Main Questions for Friday meeting
1. Is this a good way to do the models? Should we be including interaction terms?
2. Why does IntervalYears not work as an interaction term?
- Because it is being considered as a continuous variable 
3. Does the way that we're modeling reproduction (# of recruits/total area from starting point) make sense? 
    - the values are really small when normalized and especially when the interval year is included! tiny! 
4. Should we make everything into something that is on the same playing field (convert growth to something that is actually yearly)?







